{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PCILeech Firmware Generator","text":""},{"location":"#cicd-status","title":"\ud83d\udd04 CI/CD Status","text":""},{"location":"#quality-metrics","title":"\ud83d\udcca Quality Metrics","text":""},{"location":"#build-artifacts","title":"\ud83c\udfd7\ufe0f Build Artifacts","text":"<p>Generate authentic PCIe DMA firmware from real donor hardware with a single command. This tool extracts donor configurations from a local device and generates unique PCILeech FPGA bitstreams (and optionally flashes a DMA card over USB-JTAG).</p> <p>[!WARNING] This tool requires real hardware. The templates are built using the device identifiers directly from a donor card and placeholder values are explicitly avoided. Using your own donor device ensures your firmware will be unique.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code># Install with TUI support (recommended)\npip install pcileechfwgenerator[tui]\n\n# Load required kernel modules\nsudo modprobe vfio vfio-pci\n</code></pre>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python \u2265 3.9</li> <li>Donor PCIe card (any inexpensive NIC, sound, or capture card)</li> <li>Linux OS (You need this)</li> </ul>"},{"location":"#optional-requirements","title":"Optional Requirements","text":"<ul> <li>Podman (not Docker - required for proper PCIe device mounting) You use podman or run the python locally. *You must use linux for either option</li> <li>DMA board (pcileech_75t484_x1, pcileech_35t325_x4, or pcileech_100t484_x1) You don't need to flash your firmware with this tooling but you can.</li> <li>Vivado Studio (2022.2+ for synthesis and bitstream generation) You can use a locally generated Vivado project or insert the files into an existing one.</li> </ul>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code># Interactive TUI (recommended for first-time users)\nsudo python3 pcileech.py tui\n\n# CLI interface for scripted builds\nsudo python3 pcileech.py build --bdf 0000:03:00.0 --board pcileech_35t325_x1\n\n# CLI build with custom Vivado settings\nsudo python3 pcileech.py build --bdf 0000:03:00.0 --board pcileech_35t325_x1 \\\n    --vivado-path /tools/Xilinx/2025.1/Vivado --vivado-jobs 8 --vivado-timeout 7200\n\n# Check VFIO configuration\nsudo python3 pcileech.py check --device 0000:03:00.0\n\n# Flash firmware to device\nsudo python3 pcileech.py flash output/firmware.bin\n\n# Check for updates\n./cli --check-version\n\n# Skip automatic version check\n./cli build --skip-version-check --bdf 0000:03:00.0 --board pcileech_35t325_x1\n</code></pre>"},{"location":"#development-from-repository","title":"Development from Repository","text":"<pre><code>git clone https://github.com/ramseymcgrath/PCILeechFWGenerator.git\ncd PCILeechFWGenerator\npython3 -m venv .venv &amp;&amp; source .venv/bin/activate\npip install -r requirements.txt\nsudo -E python3 pcileech.py tui\n</code></pre>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li>Donor Hardware Analysis: Extract real PCIe device configurations and register maps from live hardware via VFIO</li> <li>Dynamic Device Capabilities: Generate realistic network, storage, media, and USB controller capabilities with pattern-based analysis</li> <li>Full 4KB Config-Space Shadow: Complete configuration space emulation with BRAM-based overlay memory</li> <li>MSI-X Table Replication: Exact replication of MSI-X tables from donor devices with interrupt delivery logic</li> <li>Deterministic Variance Seeding: Consistent hardware variance based on device serial number for unique firmware</li> <li>Advanced SystemVerilog Generation: Comprehensive PCIe device controller with modular template architecture</li> <li>Active Device Interrupts: MSI-X interrupt controller with timer-based and event-driven interrupt generation</li> <li>Memory Overlay Mapping: BAR dispatcher with configurable memory regions and custom PIO windows</li> <li>Interactive TUI: Modern Textual-based interface with real-time device monitoring and guided workflows</li> <li>Containerized Build Pipeline: Podman-based synthesis environment with automated VFIO setup</li> <li>Automated Testing and Validation: Comprehensive test suite with SystemVerilog assertions and Python unit tests</li> <li>USB-JTAG Flashing: Direct firmware deployment to DMA boards via integrated flash utilities</li> </ul> <p>\ud83d\udcda Complete Documentation | \ud83d\udd27 Troubleshooting Guide | \ud83c\udfd7\ufe0f Device Cloning Guide | \u26a1 Dynamic Capabilities | \ud83d\udee0\ufe0f Development Setup</p>"},{"location":"#use-cases","title":"\ud83c\udfaf Use Cases","text":""},{"location":"#security-research","title":"\ud83d\udd2c Security Research","text":"<ul> <li>Penetration testing and red team operations</li> <li>Hardware security assessment</li> <li>DMA attack research and defense</li> </ul>"},{"location":"#educational","title":"\ud83c\udf93 Educational","text":"<ul> <li>PCIe protocol learning and experimentation</li> <li>FPGA development education</li> <li>Hardware security training</li> </ul>"},{"location":"#development","title":"\ud83e\uddea Development","text":"<ul> <li>PCIe device driver development</li> <li>Hardware debugging and analysis</li> <li>Custom DMA solution prototyping</li> </ul>"},{"location":"#architecture-overview","title":"\ud83c\udfdb\ufe0f Architecture Overview","text":"<p>The PCILeech Firmware Generator uses a sophisticated multi-layer architecture:</p> <pre><code>graph TD\n    A[Donor Device] --&gt; B[VFIO Driver]\n    B --&gt; C[Configuration Extraction]\n    C --&gt; D[Device Analysis]\n    D --&gt; E[Template Engine]\n    E --&gt; F[SystemVerilog Generation]\n    F --&gt; G[FPGA Bitstream]\n    G --&gt; H[DMA Card]\n</code></pre>"},{"location":"#core-components","title":"Core Components","text":"<ul> <li>Configuration Space Manager: Handles PCIe config space extraction and emulation</li> <li>Template Architecture: Flexible template system for firmware generation</li> <li>Device Capabilities: Dynamic PCIe capability detection and implementation</li> <li>Build System: Automated FPGA project generation and building</li> </ul>"},{"location":"#requirements_1","title":"\ud83d\udccb Requirements","text":""},{"location":"#system-requirements","title":"System Requirements","text":"<ul> <li>Operating System: Linux (any modern distribution)</li> <li>Python: 3.8 or higher (3.9+ recommended)</li> <li>Memory: 4GB RAM minimum, 8GB recommended</li> <li>Storage: 2GB free space for build artifacts</li> </ul>"},{"location":"#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>Donor PCIe Device: Any PCIe device for configuration extraction</li> <li>FPGA Board: pcileech_35t325_x4, pcileech_75t484_x1, or pcileech_100t484_x1</li> <li>USB-JTAG: For optional FPGA programming</li> </ul>"},{"location":"#software-dependencies","title":"Software Dependencies","text":"<ul> <li>VFIO Drivers: For donor device access</li> <li>Podman (optional): For containerized builds</li> <li>Xilinx Vivado: 2022.2+ for synthesis (optional)</li> <li>Git: For repository management</li> </ul>"},{"location":"#supported-devices","title":"\ud83c\udfaf Supported Devices","text":"<p>The generator supports a wide range of PCIe devices:</p> <ul> <li>Network Cards: Intel, Broadcom, Mellanox</li> <li>Storage Controllers: NVMe, SATA, SAS</li> <li>Graphics Cards: NVIDIA, AMD (basic support)</li> <li>Audio Controllers: Creative, Realtek, Intel HD Audio</li> <li>USB Controllers: Intel, AMD, NEC</li> <li>Custom Hardware: Any standard PCIe device</li> </ul> <p>For a complete list, see Supported Devices.</p>"},{"location":"#troubleshooting","title":"\ud83d\udd27 Troubleshooting","text":"<p>Having issues? Check our comprehensive Troubleshooting Guide which covers:</p> <ul> <li>VFIO Setup Issues - IOMMU configuration, module loading, device binding</li> <li>Installation Problems - Package dependencies, container setup</li> <li>BAR Detection Issues - Power state problems, device compatibility  </li> <li>Device-Specific Issues - Known problems with specific hardware</li> </ul> <p>Quick diagnostic command:</p> <pre><code># Check VFIO setup and device compatibility\nsudo python3 pcileech.py check --device 0000:03:00.0 --interactive\n</code></pre>"},{"location":"#direct-documentation-links","title":"\ud83d\udd17 Direct Documentation Links","text":"<ul> <li>Troubleshooting Guide - Comprehensive troubleshooting and diagnostic guide</li> <li>Device Cloning Process - Complete guide to the cloning workflow</li> <li>Firmware Uniqueness - How authenticity is achieved</li> <li>Manual Donor Dump - Step-by-step manual extraction</li> <li>Development Setup - Contributing and development guide</li> <li>TUI Documentation - Interactive interface guide</li> <li>Config space info - Config space shadow info</li> </ul>"},{"location":"#cleanup-safety","title":"\ud83e\uddf9 Cleanup &amp; Safety","text":"<ul> <li>Rebind donors: Use TUI/CLI to rebind donor devices to original drivers</li> <li>Keep firmware private: Generated firmware contains real device identifiers</li> <li>Use isolated build environments: Never build on production systems</li> <li>Container cleanup: <code>podman rmi pcileechfwgenerator:latest</code></li> </ul>"},{"location":"#security-considerations","title":"\ud83d\udee1\ufe0f Security Considerations","text":"<p>[!IMPORTANT] This tool is intended for educational research and legitimate PCIe development purposes only. Users are responsible for ensuring compliance with all applicable laws and regulations. The authors assume no liability for misuse of this software.</p>"},{"location":"#best-practices","title":"Best Practices","text":"<ul> <li>Only use on systems you own or have explicit permission to test</li> <li>Follow responsible disclosure for any vulnerabilities discovered</li> <li>Respect intellectual property and licensing requirements</li> <li>Use appropriate safety measures when working with hardware</li> </ul>"},{"location":"#community","title":"\ud83e\udd1d Community","text":"<ul> <li>GitHub: Issues and Pull Requests</li> <li>Discord: Join our community server</li> <li>Documentation: Comprehensive guides and tutorials</li> </ul>"},{"location":"#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<ul> <li>PCILeech Community: For feedback and contributions</li> <li>@Simonrak for the writemask implementation</li> </ul>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#legal-notice","title":"\u2696\ufe0f Legal Notice","text":"<p>AGAIN This tool is intended for educational research and legitimate PCIe development purposes only. Users are responsible for ensuring compliance with all applicable laws and regulations. The authors assume no liability for misuse of this software.</p> <p>Security Considerations:</p> <ul> <li>Never build firmware on systems used for production or sensitive operations</li> <li>Use isolated build environments (Separate dedicated hardware)</li> <li>Keep generated firmware private and secure</li> <li>Follow responsible disclosure practices for any security research</li> <li>Use the SECURITY.md template to raise security concerns</li> </ul> <p>Ready to get started? Check out our Installation Guide or dive into the Quick Start tutorial!</p>"},{"location":"config-space-shadow/","title":"Configuration Space Shadow BRAM Implementation","text":"<p>This document describes the implementation of the full 4 KB configuration space shadow in BRAM for the PCILeech FPGA firmware generator.</p>"},{"location":"config-space-shadow/#overview","title":"Overview","text":"<p>The configuration space shadow BRAM implementation provides a complete 4 KB PCI Express configuration space in block RAM (BRAM) on the FPGA. This is a critical component for PCIe device emulation, as it allows the PCILeech firmware to accurately respond to configuration space accesses from the host system.</p> <p>Key features:</p> <ul> <li>Full 4 KB configuration space shadow in BRAM</li> <li>Dual-port access for simultaneous read/write operations</li> <li>Overlay RAM for writable fields (Command/Status registers)</li> <li>Initialization from device configuration data or synthetic generation</li> <li>Little-endian format compatible with PCIe specification</li> <li>Automatic overlay mapping for writable registers</li> </ul>"},{"location":"config-space-shadow/#architecture","title":"Architecture","text":"<p>The implementation consists of the following components:</p> <ol> <li>Configuration Space BRAM: A 4 KB block RAM that stores the entire configuration space of the emulated PCIe device.</li> <li>Overlay RAM: A smaller RAM that stores writable fields, allowing the host to modify certain configuration registers.</li> <li>State Machine: Handles PCIe configuration space access requests (reads and writes).</li> <li>Overlay Mapper: Automatically detects which registers need overlay entries based on PCIe specifications.</li> </ol>"},{"location":"config-space-shadow/#systemverilog-modules","title":"SystemVerilog Modules","text":"<ul> <li><code>pcileech_tlps128_cfgspace_shadow.sv</code>: The main module implementing the configuration space shadow.</li> <li><code>pcileech_tlps128_bar_controller.sv</code>: The BAR controller that interfaces with the configuration space shadow.</li> </ul>"},{"location":"config-space-shadow/#configuration-space-generation","title":"Configuration Space Generation","text":"<p>The configuration space is generated through multiple methods depending on the available data:</p>"},{"location":"config-space-shadow/#1-vfio-based-configuration-space-reading","title":"1. VFIO-based Configuration Space Reading","text":"<p>For devices bound to VFIO drivers, the system reads the actual configuration space:</p> <ol> <li>The <code>ConfigSpaceManager</code> class handles VFIO device binding and configuration space access.</li> <li>Configuration space is read via VFIO region info queries or sysfs fallback.</li> <li>The raw configuration space data is extracted and validated.</li> <li>Extended configuration space (up to 4 KB) is supported when available.</li> </ol>"},{"location":"config-space-shadow/#2-synthetic-configuration-space-generation","title":"2. Synthetic Configuration Space Generation","text":"<p>When VFIO data is not available, the system generates synthetic configuration space:</p> <ol> <li>The <code>ConfigSpaceManager.generate_synthetic_config_space()</code> method creates a complete 4 KB configuration space.</li> <li>Device identification data is populated from device profiles.</li> <li>Standard PCI header fields are generated with appropriate defaults.</li> <li>Capability structures (MSI, MSI-X, PCIe) are added based on device requirements.</li> <li>BAR configurations are populated based on device analysis.</li> </ol>"},{"location":"config-space-shadow/#3-configuration-space-initialization","title":"3. Configuration Space Initialization","text":"<p>The generated configuration space is converted to FPGA-compatible format:</p> <ol> <li>The <code>ConfigSpaceHexFormatter</code> class converts binary data to hex format.</li> <li>Data is formatted as 32-bit words in little-endian format.</li> <li>A <code>config_space_init.hex</code> file is generated for SystemVerilog <code>$readmemh</code> initialization.</li> <li>Comments are added for debugging and register identification.</li> </ol>"},{"location":"config-space-shadow/#overlay-ram-for-writable-fields","title":"Overlay RAM for Writable Fields","text":"<p>The overlay RAM provides a mechanism for handling writable fields in the configuration space. The <code>OverlayMapper</code> class automatically detects which registers need overlay entries based on PCIe specifications:</p>"},{"location":"config-space-shadow/#automatic-overlay-detection","title":"Automatic Overlay Detection","text":"<p>The system automatically identifies writable registers:</p> <ul> <li>Standard PCI registers: Command, Status, Cache Line Size, Latency Timer, BIST</li> <li>BAR registers: Detected as special handling type with size-based masks</li> <li>Capability registers: MSI, MSI-X, PCIe capability registers with mixed read/write fields</li> <li>Extended capabilities: AER, Power Management, and other extended capabilities</li> </ul>"},{"location":"config-space-shadow/#overlay-operation","title":"Overlay Operation","text":"<p>When reading from a register with writable fields:</p> <ol> <li>The base value is read from the main configuration space BRAM</li> <li>The overlay mask determines which bits come from overlay RAM</li> <li>The final value combines: <code>(base_value &amp; ~mask) | (overlay_value &amp; mask)</code></li> </ol> <p>When writing to a register with writable fields:</p> <ol> <li>Only the writable bits (defined by the mask) are updated in overlay RAM</li> <li>Read-only bits remain unchanged in the base configuration space</li> </ol>"},{"location":"config-space-shadow/#integration-with-build-process","title":"Integration with Build Process","text":"<p>The configuration space shadow is integrated into the build process through the <code>PCILeechGenerator</code> and template system:</p>"},{"location":"config-space-shadow/#template-based-generation","title":"Template-based Generation","text":"<ol> <li>Template Context Building: The <code>PCILeechContextBuilder</code> creates a comprehensive template context containing:</li> <li>Device configuration data from VFIO or synthetic generation</li> <li>Overlay mapping automatically generated by <code>OverlayMapper</code></li> <li>Extended configuration space pointers</li> <li> <p>MSI-X and capability configurations</p> </li> <li> <p>SystemVerilog Generation: The <code>AdvancedSVGenerator</code> processes templates to create:</p> </li> <li>Configuration space shadow module (<code>cfg_shadow.sv</code>)</li> <li>Configuration space initialization file (<code>config_space_init.hex</code>)</li> <li> <p>Overlay constants and lookup tables</p> </li> <li> <p>Hex File Generation: The <code>ConfigSpaceHexFormatter</code> converts configuration space data to:</p> </li> <li>Little-endian 32-bit words</li> <li>Vivado-compatible hex format</li> <li>Debug comments for register identification</li> </ol>"},{"location":"config-space-shadow/#build-integration","title":"Build Integration","text":"<ol> <li>The configuration space shadow module is automatically included in the generated TCL script.</li> <li>The <code>config_space_init.hex</code> file is included in the project for BRAM initialization.</li> <li>Overlay constants are generated as SystemVerilog parameters for efficient lookup.</li> </ol>"},{"location":"config-space-shadow/#systemverilog-implementation-details","title":"SystemVerilog Implementation Details","text":""},{"location":"config-space-shadow/#configuration-space-shadow-module","title":"Configuration Space Shadow Module","text":"<p>The main module (<code>pcileech_tlps128_cfgspace_shadow</code>) implements:</p> <ul> <li>Dual-port BRAM: Main configuration space storage with parameterized size</li> <li>Overlay RAM: Separate storage for writable fields with automatic indexing</li> <li>State Machine: Handles PCIe configuration reads/writes with overlay logic</li> <li>Shadow Control: Determines when to use shadow vs. hardware based on address ranges</li> </ul>"},{"location":"config-space-shadow/#key-features","title":"Key Features","text":"<ul> <li>Automatic Overlay Mapping: Lookup tables generated from <code>OVERLAY_MAP</code> template data</li> <li>Byte-enable Support: Proper handling of partial register writes</li> <li>Extended Configuration Space: Support for capabilities beyond standard 256 bytes</li> <li>CFGTLP Integration: Proper integration with PCIe configuration TLP handling</li> </ul>"},{"location":"config-space-shadow/#testing","title":"Testing","text":"<p>The implementation includes comprehensive testing:</p> <ol> <li>Python Unit Tests:</li> <li><code>test_config_space_manager.py</code>: Tests for configuration space reading and generation</li> <li><code>test_overlay_mapper.py</code>: Tests for overlay detection and mapping</li> <li> <p><code>test_hex_formatter.py</code>: Tests for hex file generation and formatting</p> </li> <li> <p>Integration Tests:</p> </li> <li>VFIO binding and configuration space access</li> <li>Synthetic configuration space generation</li> <li>Template rendering and context building</li> </ol>"},{"location":"config-space-shadow/#usage","title":"Usage","text":"<p>The configuration space shadow is automatically included in the build process. The system:</p> <ol> <li>Detects Device Configuration: Automatically reads from VFIO or generates synthetic data</li> <li>Maps Overlay Requirements: Automatically detects which registers need overlay entries</li> <li>Generates SystemVerilog: Creates the shadow module with proper initialization</li> <li>Integrates with Build: Includes all necessary files in the FPGA project</li> </ol>"},{"location":"config-space-shadow/#configuration-options","title":"Configuration Options","text":"<p>The system supports various configuration options:</p> <ul> <li>CONFIG_SPACE_SIZE: Parameterized size (256 bytes to 4 KB)</li> <li>OVERLAY_ENTRIES: Number of overlay RAM entries (automatically calculated)</li> <li>EXT_CFG_CAP_PTR: Extended capability pointer offset</li> <li>DUAL_PORT: Optional dual-port BRAM configuration</li> </ul>"},{"location":"config-space-shadow/#limitations","title":"Limitations","text":"<ul> <li>The current implementation supports a single PCIe function (function 0).</li> <li>Overlay RAM has a practical limit based on FPGA resources.</li> <li>Extended capabilities are limited to commonly used types.</li> </ul>"},{"location":"config-space-shadow/#future-enhancements","title":"Future Enhancements","text":"<p>Possible future enhancements include:</p> <ul> <li>Support for multiple PCIe functions</li> <li>Dynamic reconfiguration of the configuration space</li> <li>Enhanced error handling and reporting</li> <li>Support for device-specific extended capabilities</li> </ul>"},{"location":"development/","title":"\ud83d\udee0\ufe0f Development Guide","text":"<p>The code needs to run on linux but can be developed anywhere with a python vers &gt;3.9</p> <pre><code># Clone repository\ngit clone https://github.com/ramseymcgrath/PCILeechFWGenerator\ncd PCILeechFWGenerator\n\n# Create virtual environment\npython3 -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install development dependencies\npip install -r requirements-dev.txt\n\n# Install pre-commit hooks\npre-commit install\n\n# Run tests\npytest tests/\n</code></pre>"},{"location":"development/#building-from-source","title":"\ud83d\udce6 Building from Source","text":"<pre><code># Build distributions\npython -m build\n\n# Install locally\npip install dist/*.whl\n</code></pre>"},{"location":"development/#unit-testing","title":"Unit testing","text":"<p>TUI Tests are next to the code in the tui dir, app tests are in the tests/ dir. <code>make test</code> in the repo is the easiest way to run unit tests locally. The github action will run them in CI.</p>"},{"location":"development/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Please see <code>CONTRIBUTING.md</code> for detailed guidelines.</p> <p>Quick Start: 1. Fork the repository 2. Create a feature branch (<code>git checkout -b feature/amazing-feature</code>) 3. Make your changes with tests 4. Submit a pull request</p>"},{"location":"development/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<p>The project is structured as follows:</p> <ul> <li>Core Generator: Main PCILeech firmware generation logic</li> <li>TUI Interface: Modern terminal interface using Textual</li> <li>VFIO Integration: Linux VFIO driver interaction</li> <li>Template System: SystemVerilog template processing</li> <li>Testing Framework: Comprehensive test suite</li> </ul>"},{"location":"development/#coding-standards","title":"\ud83d\udcdd Coding Standards","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Use type hints for all functions</li> <li>Write comprehensive docstrings</li> <li>Add unit tests for new features</li> <li>Use descriptive commit messages</li> </ul>"},{"location":"development/#debugging","title":"\ud83d\udd0d Debugging","text":"<p>The project includes extensive logging and debugging features:</p> <pre><code># Enable debug logging\nexport PCILEECH_DEBUG=1\nsudo -E python3 pcileech.py build --debug\n\n# Use interactive debugger\nsudo -E python3 -m pdb pcileech.py build\n</code></pre>"},{"location":"development/#container-development","title":"\ud83d\udc33 Container Development","text":"<pre><code># Build development container\npodman build -t pcileech-dev .\n\n# Run with development mounts\npodman run -it --privileged \\\n  -v $(pwd):/workspace \\\n  pcileech-dev bash\n</code></pre>"},{"location":"device-cloning/","title":"Device Cloning","text":"<p>The device cloning process creates an FPGA-based replica of a PCIe device through systematic hardware analysis and template generation. This section details the multi-stage process and error handling mechanisms.</p>"},{"location":"device-cloning/#prerequisites-and-system-requirements","title":"Prerequisites and System Requirements","text":"<p>Before cloning begins, the system must meet specific requirements:</p> <ul> <li>IOMMU Support: Intel VT-d or AMD-Vi must be enabled in BIOS/UEFI</li> <li>Kernel Configuration: VFIO modules loaded (<code>vfio</code>, <code>vfio-pci</code>, <code>vfio_iommu_type1</code>)</li> <li>Root Privileges: Required for VFIO device binding operations</li> <li>Fallback Mode: For testing environments without IOMMU, use <code>iommu=pt</code> or <code>vfio.enable_unsafe_noiommu_mode=1</code></li> </ul>"},{"location":"device-cloning/#stage-1-vfio-device-acquisition","title":"Stage 1: VFIO Device Acquisition","text":"<p>The generator establishes exclusive control over the target PCIe device through Linux VFIO:</p> <ol> <li>IOMMU Group Discovery: Identifies all devices sharing the same IOMMU group as the target BDF (e.g., <code>0000:01:00.0</code>)</li> <li>Driver Unbinding: Safely unbinds existing kernel drivers from all group members</li> <li>VFIO Binding: Rebinds devices to the <code>vfio-pci</code> driver for userspace access</li> <li>Handle Creation: Establishes <code>/dev/vfio/&lt;group&gt;</code> interface for safe device interaction</li> </ol> <p>Error Handling:</p> <ul> <li>IOMMU Unavailable: Falls back to heuristic size estimation (requires explicit enablement)</li> <li>Driver Conflicts: Automatically handles in-use drivers with graceful fallback</li> <li>Permission Errors: Provides clear diagnostic messages for privilege escalation</li> </ul>"},{"location":"device-cloning/#stage-2-configuration-space-analysis","title":"Stage 2: Configuration Space Analysis","text":"<p>The generator performs comprehensive configuration space extraction:</p>"},{"location":"device-cloning/#standard-pci-header-0x00-0xff","title":"Standard PCI Header (0x00-0xFF)","text":"<ul> <li>Device Identity: Vendor ID, Device ID, Subsystem IDs, Class Code, Revision</li> <li>Command/Status: Capability flags, error status, device state</li> <li>BAR Registers: Base Address Registers 0-5 with size and type information</li> <li>Interrupt Configuration: Legacy INTx pin assignments</li> </ul>"},{"location":"device-cloning/#extended-configuration-space-0x100-0xfff","title":"Extended Configuration Space (0x100-0xFFF)","text":"<ul> <li>Capability Structures: MSI/MSI-X, Power Management, PCIe-specific capabilities</li> <li>Vendor-Specific: Custom capability blocks preserved byte-for-byte</li> <li>Advanced Features: AER, VC, PASID, and other modern PCIe capabilities</li> </ul> <p>Validation and Security:</p> <ul> <li>Checksum Generation: SHA-256 hash of configuration space prevents generic firmware</li> <li>Signature Verification: Ensures unique firmware per donor device</li> <li>Sanitization: Removes potentially sensitive vendor-specific data when requested</li> </ul>"},{"location":"device-cloning/#stage-3-bar-discovery-and-memory-mapping","title":"Stage 3: BAR Discovery and Memory Mapping","text":"<p>Systematic analysis of Base Address Registers determines memory layout:</p> <pre><code>For each BAR index (0-5):\n\u251c\u2500\u2500 Issue VFIO_DEVICE_GET_REGION_INFO ioctl\n\u251c\u2500\u2500 Extract: size, read/write permissions, mmap capability\n\u251c\u2500\u2500 Filter: Ignore I/O ports and zero-sized regions\n\u251c\u2500\u2500 Record: All valid MMIO BARs with metadata\n\u2514\u2500\u2500 Select: Largest MMIO BAR as primary window\n</code></pre> <p>Advanced BAR Handling:</p> <ul> <li>64-bit BARs: Properly handles paired 32-bit registers</li> <li>Prefetchable Memory: Preserves caching hints and optimization flags</li> <li>Size Validation: Ensures BAR sizes are power-of-2 aligned</li> <li>Conflict Resolution: Handles overlapping or invalid BAR configurations</li> </ul> <p>Fallback Mechanisms:</p> <ul> <li>Heuristic Sizing: When VFIO fails, estimates BAR sizes from register patterns</li> <li>Conservative Defaults: Uses safe minimum sizes for critical BARs</li> <li>Manual Override: Allows explicit BAR configuration via command-line parameters</li> </ul>"},{"location":"device-cloning/#stage-4-interrupt-architecture-analysis","title":"Stage 4: Interrupt Architecture Analysis","text":"<p>The generator determines optimal interrupt emulation strategy:</p>"},{"location":"device-cloning/#priority-order-highest-to-lowest","title":"Priority Order (Highest to Lowest)","text":"<ol> <li>MSI-X: Multi-vector message signaled interrupts</li> <li>Validates table size &gt; 0</li> <li>Preserves vector count and table structure</li> <li> <p>Maps interrupt vectors to FPGA resources</p> </li> <li> <p>MSI: Single-vector message signaled interrupts</p> </li> <li>Fallback when MSI-X unavailable</li> <li> <p>Simpler implementation with single interrupt line</p> </li> <li> <p>Legacy INTx: Pin-based interrupts</p> </li> <li>Last resort for older devices</li> <li>Emulates traditional interrupt sharing</li> </ol> <p>Capability Validation:</p> <ul> <li>Table Size Verification: Ensures MSI-X table is properly sized</li> <li>Vector Count Limits: Respects hardware and software constraints</li> <li>Interrupt Routing: Validates interrupt pin assignments</li> </ul>"},{"location":"device-cloning/#stage-5-template-context-generation","title":"Stage 5: Template Context Generation","text":"<p>All extracted data is consolidated into a comprehensive template context:</p>"},{"location":"device-cloning/#core-components","title":"Core Components","text":"<ul> <li>Device Identity: Complete PCI configuration header</li> <li>Memory Layout: BAR map with sizes, types, and access patterns</li> <li>Interrupt Configuration: Selected interrupt mechanism with parameters</li> <li>Timing Parameters: Clock domains, reset sequences, power states</li> <li>Feature Flags: DMA capabilities, error handling, debug interfaces</li> </ul>"},{"location":"device-cloning/#validation-pipeline","title":"Validation Pipeline","text":"<pre><code>Context Validation:\n\u251c\u2500\u2500 Required Fields Check\n\u2502   \u251c\u2500\u2500 Non-zero Vendor ID\n\u2502   \u251c\u2500\u2500 Valid Device Class\n\u2502   \u2514\u2500\u2500 Usable MMIO BAR present\n\u251c\u2500\u2500 Consistency Verification\n\u2502   \u251c\u2500\u2500 BAR size alignment\n\u2502   \u251c\u2500\u2500 Capability chain integrity\n\u2502   \u2514\u2500\u2500 Interrupt configuration validity\n\u2514\u2500\u2500 Security Validation\n    \u251c\u2500\u2500 Signature uniqueness\n    \u251c\u2500\u2500 No default/generic patterns\n    \u2514\u2500\u2500 Sanitized vendor data\n</code></pre> <p>Error Recovery:</p> <ul> <li>Missing BARs: Provides synthetic minimal BAR configuration</li> <li>Invalid Capabilities: Gracefully degrades to simpler interrupt modes</li> <li>Corrupted Data: Attempts repair or fails with detailed diagnostics</li> </ul>"},{"location":"device-cloning/#stage-6-firmware-generation","title":"Stage 6: Firmware Generation","text":"<p>The validated context drives the Jinja2/SystemVerilog template engine:</p>"},{"location":"device-cloning/#output-artifacts","title":"Output Artifacts","text":"<ul> <li>FPGA Bitstream: Device-specific <code>.bit</code> or <code>.bin</code> file</li> <li>Configuration Headers: C/C++ headers for host software integration</li> <li>JSON Metadata: Machine-readable device description</li> <li>Build Reports: Synthesis timing, resource utilization, verification results</li> </ul>"},{"location":"device-cloning/#quality-assurance","title":"Quality Assurance","text":"<ul> <li>Template Validation: Ensures generated Verilog is syntactically correct</li> <li>Resource Estimation: Predicts FPGA utilization before synthesis</li> <li>Timing Analysis: Validates clock domain crossings and setup/hold times</li> </ul>"},{"location":"device-cloning/#quick-start-command","title":"Quick Start Command","text":"<pre><code># Enable IOMMU and run generator\nsudo python3 pcileech.py build --bdf 0000:01:00.0 --board pcileech_35t325_x4\n</code></pre>"},{"location":"dynamic-device-capabilities/","title":"Dynamic Device Capabilities","text":""},{"location":"dynamic-device-capabilities/#overview","title":"Overview","text":"<p>The PCILeech Firmware Generator includes advanced dynamic device capability generation that creates realistic PCIe device configurations based on build-time provided vendor and device IDs. This system generates authentic device capabilities without hardcoding, ensuring unique and secure firmware generation.</p> <p>The dynamic capability system analyzes vendor/device ID patterns to generate realistic PCIe capabilities, BARs, and device features for multiple device categories:</p> <ul> <li>Network Functions: Ethernet, WiFi, Bluetooth, Cellular controllers</li> <li>Storage Functions: NVMe, SATA, RAID, SCSI, IDE controllers  </li> <li>Media Functions: HD Audio, Video, Multimedia controllers</li> <li>USB Functions: USB4, xHCI, EHCI, UHCI, OHCI controllers</li> </ul>"},{"location":"dynamic-device-capabilities/#key-features","title":"Key Features","text":""},{"location":"dynamic-device-capabilities/#pattern-based-analysis","title":"Pattern-Based Analysis","text":"<ul> <li>No Hardcoded Devices: Uses vendor-specific patterns and device ID ranges</li> <li>Dynamic Scaling: Higher device IDs generate more advanced capabilities</li> <li>Vendor Recognition: Intel, AMD, NVIDIA, Broadcom, Realtek patterns</li> <li>Security-Focused: Prevents signature duplication through dynamic generation</li> </ul>"},{"location":"dynamic-device-capabilities/#realistic-capabilities","title":"Realistic Capabilities","text":"<ul> <li>SR-IOV: Up to 64 Virtual Functions for enterprise devices</li> <li>MSI-X: Appropriate vector counts based on device complexity</li> <li>Advanced Error Reporting: For storage and high-reliability devices</li> <li>Modern Features: PTM, LTR, ACS for time-sensitive and isolated functions</li> </ul>"},{"location":"dynamic-device-capabilities/#production-ready","title":"Production Ready","text":"<ul> <li>Build Integration: Single function call with vendor/device IDs from build process</li> <li>Error Handling: Comprehensive logging with existing infrastructure</li> <li>Type Safety: Full type hints and structured output</li> <li>Fallback Handling: Generic capabilities for unknown device types</li> </ul>"},{"location":"dynamic-device-capabilities/#device-categories","title":"Device Categories","text":""},{"location":"dynamic-device-capabilities/#network-functions","title":"Network Functions","text":"<p>Generate realistic network controller capabilities:</p> <pre><code>from pci_capability.dynamic_functions import get_network_capabilities\n\n# Generate network capabilities from build-time IDs\nconfig = get_network_capabilities(vendor_id=0x8086, device_id=0x1572)\n</code></pre> <p>Supported Features:</p> <ul> <li>Ethernet Controllers: 1GbE to 100GbE with queue scaling</li> <li>WiFi Controllers: 802.11ac/ax/be with MIMO support</li> <li>Advanced Capabilities: SR-IOV, ACS, LTR, PTM for enterprise devices</li> <li>Realistic BARs: Register spaces, MSI-X tables, flash/EEPROM regions</li> <li>Feature Scaling: Queue counts, VF counts, link speeds based on device ID</li> </ul> <p>Example Output:</p> <ul> <li>Intel X710 pattern (0x8086:0x1572): 10GbE, SR-IOV (32 VFs), MSI-X (64 vectors)</li> <li>Realtek RTL8111 pattern (0x10ec:0x8168): 1GbE, basic MSI, standard features</li> </ul>"},{"location":"dynamic-device-capabilities/#storage-functions","title":"Storage Functions","text":"<p>Generate comprehensive storage controller capabilities:</p> <pre><code>from pci_capability.dynamic_functions import get_storage_capabilities\n\nconfig = get_storage_capabilities(vendor_id=0x144d, device_id=0xa808)\n</code></pre> <p>Supported Categories:</p> <ul> <li>NVMe Controllers: Multiple namespaces, admin/IO queues, TRIM support</li> <li>SATA AHCI: NCQ, hotplug, multi-port configurations</li> <li>RAID Controllers: Multiple RAID levels, cache, battery backup for enterprise</li> <li>SCSI Controllers: Tagged queuing, multiple targets, version scaling</li> <li>Legacy IDE: UDMA, DMA support for older systems</li> </ul> <p>Dynamic Features:</p> <ul> <li>Queue Depths: 16-1024 based on device complexity</li> <li>Namespace Counts: 16-1024 for NVMe based on device ID</li> <li>Port Counts: 4-8 SATA ports for controllers</li> <li>Cache Sizes: 512MB-2GB for RAID controllers</li> </ul>"},{"location":"dynamic-device-capabilities/#media-functions","title":"Media Functions","text":"<p>Generate audio and video controller capabilities:</p> <pre><code>from pci_capability.dynamic_functions import get_media_capabilities\n\nconfig = get_media_capabilities(vendor_id=0x8086, device_id=0x0c0c)\n</code></pre> <p>Supported Types:</p> <ul> <li>HD Audio Controllers: Multi-channel, high sample rates, codec support</li> <li>Basic Audio: Legacy stereo with power management</li> <li>Video Controllers: Hardware acceleration, frame buffers, resolution scaling</li> </ul> <p>Dynamic Scaling:</p> <ul> <li>Channel Counts: 2-8 channels based on device capability</li> <li>Sample Rates: 44.1kHz-192kHz for high-end devices</li> <li>Video Memory: 64MB-512MB based on device ID</li> <li>Resolutions: 720p-4K support scaling</li> </ul>"},{"location":"dynamic-device-capabilities/#usb-functions","title":"USB Functions","text":"<p>Generate USB controller capabilities for all USB standards:</p> <pre><code>from pci_capability.dynamic_functions import get_usb_capabilities\n\nconfig = get_usb_capabilities(vendor_id=0x1912, device_id=0x0015)\n</code></pre> <p>Controller Types:</p> <ul> <li>USB4: 40Gbps, Thunderbolt compatibility, advanced features</li> <li>xHCI: USB 3.x, streams, multiple interrupters</li> <li>EHCI: USB 2.0, companion controller support</li> <li>Legacy: UHCI/OHCI for USB 1.1 compatibility</li> </ul> <p>Port Scaling:</p> <ul> <li>USB4: 2-4 ports based on device complexity</li> <li>xHCI: 4-16 ports with MSI-X support</li> <li>EHCI: 4-8 ports with companion controllers</li> <li>Legacy: 2-4 ports with basic interrupt handling</li> </ul>"},{"location":"dynamic-device-capabilities/#integration-guide","title":"Integration Guide","text":""},{"location":"dynamic-device-capabilities/#automatic-detection","title":"Automatic Detection","text":"<p>The system can automatically detect device function type:</p> <pre><code>from pci_capability.dynamic_functions import create_dynamic_device_capabilities\n\n# Auto-detect and generate appropriate capabilities\nconfig = create_dynamic_device_capabilities(\n    vendor_id=build_vendor_id,    # From your build process\n    device_id=build_device_id,    # From your build process\n    class_code=build_class_code   # Optional PCI class code\n)\n</code></pre>"},{"location":"dynamic-device-capabilities/#build-process-integration","title":"Build Process Integration","text":"<p>For direct integration into your firmware build process:</p> <pre><code># Example build integration\ndef generate_firmware_config(vendor_id: int, device_id: int, board_type: str):\n    \"\"\"Generate firmware configuration with dynamic capabilities.\"\"\"\n\n    # Generate device capabilities\n    device_config = create_dynamic_device_capabilities(vendor_id, device_id)\n\n    # Extract for firmware generation\n    capabilities = device_config['capabilities']\n    bars = device_config['bars']\n    features = device_config['features']\n\n    # Generate SystemVerilog templates\n    return render_firmware_template(\n        board_type=board_type,\n        vendor_id=vendor_id,\n        device_id=device_id,\n        class_code=device_config['class_code'],\n        capabilities=capabilities,\n        bars=bars,\n        features=features\n    )\n</code></pre>"},{"location":"dynamic-device-capabilities/#configuration-output","title":"Configuration Output","text":"<p>The dynamic system generates structured configuration:</p> <pre><code>{\n  \"vendor_id\": 32902,\n  \"device_id\": 5746,\n  \"class_code\": 131072,\n  \"capabilities\": [\n    {\n      \"cap_id\": 1,\n      \"version\": 3,\n      \"d3_support\": true,\n      \"aux_current\": 0\n    },\n    {\n      \"cap_id\": 5,\n      \"multi_message_capable\": 3,\n      \"supports_64bit\": true,\n      \"supports_per_vector_masking\": true\n    }\n  ],\n  \"bars\": [\n    {\n      \"bar\": 0,\n      \"type\": \"memory\",\n      \"size\": 131072,\n      \"prefetchable\": false,\n      \"description\": \"Device registers\"\n    }\n  ],\n  \"features\": {\n    \"category\": \"ethernet\",\n    \"queue_count\": 32,\n    \"supports_sriov\": true,\n    \"max_vfs\": 32\n  }\n}\n</code></pre>"},{"location":"dynamic-device-capabilities/#security-considerations","title":"Security Considerations","text":""},{"location":"dynamic-device-capabilities/#anti-duplication-design","title":"Anti-Duplication Design","text":"<p>The dynamic system prevents signature duplication:</p> <ul> <li>Pattern-Based: No hardcoded device lists that could create identical signatures</li> <li>ID-Based Scaling: Device capabilities scale with vendor/device ID characteristics</li> <li>Entropy Sources: Multiple device ID bits used for feature determination</li> <li>Vendor Variations: Different algorithms for different vendors</li> </ul>"},{"location":"dynamic-device-capabilities/#authenticity-features","title":"Authenticity Features","text":"<p>Generated devices maintain authenticity:</p> <ul> <li>Realistic Ranges: Capabilities stay within vendor-typical ranges</li> <li>Proper Relationships: MSI-X vectors match queue counts appropriately</li> <li>Standard Compliance: All generated capabilities follow PCIe specifications</li> <li>Error Handling: Graceful fallbacks for unknown or unusual device IDs</li> </ul>"},{"location":"dynamic-device-capabilities/#implementation-details","title":"Implementation Details","text":""},{"location":"dynamic-device-capabilities/#vendor-pattern-recognition","title":"Vendor Pattern Recognition","text":"<p>The system recognizes vendor-specific patterns:</p> <pre><code># Intel network device patterns\nif vendor_id == 0x8086:\n    if device_upper_byte in [0x15, 0x16, 0x17]:  # Ethernet ranges\n        return \"network\"\n    elif device_upper_byte in [0x24, 0x25, 0x27]:  # WiFi ranges  \n        return \"wifi\"\n</code></pre>"},{"location":"dynamic-device-capabilities/#dynamic-feature-scaling","title":"Dynamic Feature Scaling","text":"<p>Features scale based on device ID analysis:</p> <pre><code>def _calculate_queue_count(self) -&gt; int:\n    \"\"\"Calculate queue count based on device ID.\"\"\"\n    if self.device_id &gt; 0x3000:\n        return 64  # High-end device\n    elif self.device_id &gt; 0x2000:\n        return 32  # Mid-range device\n    else:\n        return 16  # Entry-level device\n</code></pre>"},{"location":"dynamic-device-capabilities/#capability-relationships","title":"Capability Relationships","text":"<p>The system maintains realistic capability relationships:</p> <ul> <li>SR-IOV + ACS: Access Control Services enabled with SR-IOV</li> <li>MSI-X + Queues: Vector counts match queue requirements</li> <li>Power Management: Appropriate aux current for device types</li> <li>BAR Layouts: Realistic register space and table layouts</li> </ul>"},{"location":"dynamic-device-capabilities/#advanced-usage","title":"Advanced Usage","text":""},{"location":"dynamic-device-capabilities/#custom-function-hints","title":"Custom Function Hints","text":"<p>Override automatic detection with explicit hints:</p> <pre><code># Force specific function type\nconfig = create_dynamic_device_capabilities(\n    vendor_id=0x8086,\n    device_id=0x1234,\n    function_hint=\"storage\"  # Force storage analysis\n)\n</code></pre>"},{"location":"dynamic-device-capabilities/#capability-filtering","title":"Capability Filtering","text":"<p>Filter capabilities for specific use cases:</p> <pre><code>def filter_basic_capabilities(config):\n    \"\"\"Keep only basic capabilities for simple devices.\"\"\"\n    basic_caps = [0x01, 0x05, 0x10]  # PM, MSI, PCIe\n    config['capabilities'] = [\n        cap for cap in config['capabilities'] \n        if cap['cap_id'] in basic_caps\n    ]\n    return config\n</code></pre>"},{"location":"dynamic-device-capabilities/#template-integration","title":"Template Integration","text":"<p>Integrate with existing template systems:</p> <pre><code>def render_device_template(vendor_id, device_id, template_name):\n    \"\"\"Render device template with dynamic capabilities.\"\"\"\n\n    # Generate capabilities\n    config = create_dynamic_device_capabilities(vendor_id, device_id)\n\n    # Render with template engine\n    return template_engine.render(\n        template_name,\n        **config,\n        timestamp=datetime.now(),\n        generator_version=\"1.0.0\"\n    )\n</code></pre>"},{"location":"dynamic-device-capabilities/#troubleshooting","title":"Troubleshooting","text":""},{"location":"dynamic-device-capabilities/#common-issues","title":"Common Issues","text":"<p>Unknown Device Type:</p> <pre><code>WARNING: Unknown function type for device 1234:5678, using generic capabilities\n</code></pre> <p>Solution: The device ID pattern wasn't recognized. Generic capabilities will be used, or provide a function hint.</p> <p>Missing Capabilities:</p> <pre><code># Add explicit capability checks\nif required_capability not in [cap['cap_id'] for cap in config['capabilities']]:\n    # Add required capability manually\n</code></pre> <p>BAR Configuration Issues:</p> <pre><code># Validate BAR layout\ntotal_bars = len(config['bars'])\nif total_bars &gt; 6:  # PCIe max BARs\n    config['bars'] = config['bars'][:6]\n</code></pre>"},{"location":"dynamic-device-capabilities/#see-also","title":"See Also","text":"<ul> <li>Device Cloning Process - Hardware-based device extraction</li> <li>Template Architecture - SystemVerilog template system</li> <li>Configuration Space Shadow - Configuration space emulation</li> <li>Supported Devices - Compatible hardware list</li> </ul>"},{"location":"firmware-uniqueness/","title":"Uniqueness Overview","text":"<p>The PCILeech firmware generator creates authentic hardware clones by performing byte-perfect replication of donor device characteristics while maintaining a stable, reusable core architecture. The result is hardware that appears identical to the original device from the host OS perspective while providing consistent, predictable behavior across builds.</p>"},{"location":"firmware-uniqueness/#key-benefits","title":"Key Benefits","text":"<ul> <li>Perfect Stealth: Identical PCIe fingerprints to donor hardware</li> <li>Build Consistency: Same core IP across all generated firmware</li> <li>Research Flexibility: Safe testing environment for security research</li> <li>Driver Compatibility: Native vendor driver support without modifications</li> </ul>"},{"location":"firmware-uniqueness/#deep-cloned-device-anatomy","title":"Deep-Cloned Device Anatomy","text":"<p>The cloning process replicates critical hardware characteristics across multiple layers:</p> Layer Cloned Components Security Impact Implementation Notes PCIe Config Space 256-byte header + Extended Capabilities (PM, MSI/MSI-X, PCIe, VSEC) Driver whitelisting, BIOS compatibility Missing capabilities trigger Code 10 errors BAR &amp; Memory Map BAR0-BAR5 sizes, flags, alignment, prefetch settings Fingerprint resistance BAR entropy analysis defeated Interrupt Topology MSI/MSI-X tables, indices, masks, PBA configuration IRQ behavior matching BRAM-mirrored for consistency Link Behavior L0s/L1 timings, Max_Read_Request, advanced PCIe features Advanced fingerprinting ASPM, OBFF, Hot-plug states Power &amp; Error Handling ASPM policies, PME support, D-states, AER masks Enterprise compliance Byte-perfect POST auditing"},{"location":"firmware-uniqueness/#configuration-space-layout","title":"Configuration Space Layout","text":"<pre><code>Offset 0x00-0xFF: Standard PCIe Header (256 bytes)\n\u251c\u2500\u2500 0x00-0x3F: Type 0/1 Configuration Header\n\u251c\u2500\u2500 0x40-0xFF: Capability Structures\n\u2514\u2500\u2500 0x100+:    Extended Capability Structures\n\nExtended Capabilities Chain:\n\u251c\u2500\u2500 Power Management (PM)\n\u251c\u2500\u2500 Message Signaled Interrupts (MSI/MSI-X)  \n\u251c\u2500\u2500 PCIe Capability Structure\n\u251c\u2500\u2500 Vendor Specific Extended Capability (VSEC)\n\u2514\u2500\u2500 Advanced Error Reporting (AER)\n</code></pre>"},{"location":"firmware-uniqueness/#build-time-security-features","title":"Build-Time Security Features","text":""},{"location":"firmware-uniqueness/#entropy-generation","title":"Entropy Generation","text":"<ul> <li>Unique Bitstreams: SHA-256 hash of donor configuration salted into unused BRAM</li> <li>Forensic Tracking: Vivado version and build timestamp embedded in hidden VSEC</li> <li>P&amp;R Randomization: IO placement randomized within timing constraints</li> <li>Anti-Analysis: Defeats simple bitstream diffing and pattern recognition</li> </ul>"},{"location":"firmware-uniqueness/#implementation-details","title":"Implementation Details","text":"<pre><code>// Example: Build-time entropy injection\nlocalparam [255:0] BUILD_ENTROPY = 256'h{SHA256_HASH};\nlocalparam [63:0]  BUILD_TIMESTAMP = 64'h{UNIX_TIMESTAMP};\n\n// Hidden in unused VSEC register space\nassign vsec_entropy_reg = BUILD_ENTROPY[31:0];\nassign vsec_timestamp_reg = BUILD_TIMESTAMP[31:0];\n</code></pre>"},{"location":"firmware-uniqueness/#detection-resistance-validation","title":"Detection-Resistance Validation","text":""},{"location":"firmware-uniqueness/#automated-testing-matrix","title":"Automated Testing Matrix","text":"Test Category Tool/Method Expected Behavior Failure Indicators Basic Enumeration <code>lspci -vvv</code>, <code>pcieutils</code> Identical vendor/device IDs, capability offsets Mismatched PCI IDs, capability gaps Driver Loading Windows Device Manager, Linux modprobe Native vendor driver loads without warnings Code 10 errors, unsigned driver prompts Stress Testing MSI flood tests, hot-reset cycles Stable operation under load System hangs, IRQ storms Security Scanning Anti-tamper suites (Falcon, Ranger) No anomaly alerts Link state mismatches, timing deviations Power Management ASPM state transitions, D-state cycling Identical power behavior to donor PME assertion failures, ASPM violations"},{"location":"firmware-uniqueness/#validation-scripts","title":"Validation Scripts","text":"<pre><code>#!/bin/bash\n# Basic validation suite\necho \"=== PCIe Device Validation ===\"\n\n# Check PCI configuration space\nlspci -s $DEVICE_BDF -vvv &gt; current_config.txt\ndiff -u donor_config.txt current_config.txt\n\n# Verify driver loading\nif lsmod | grep -q $EXPECTED_DRIVER; then\n    echo \"\u2713 Driver loaded successfully\"\nelse\n    echo \"\u2717 Driver loading failed\"\nfi\n\n# Test MSI-X functionality  \necho \"Testing interrupt handling...\"\n./test_msix_vectors $DEVICE_BDF\n</code></pre>"},{"location":"firmware-uniqueness/#immutable-core-architecture","title":"Immutable Core Architecture","text":"<p>The firmware maintains a stable core while adapting the peripheral interface:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Donor-Specific Shell          \u2502 \u2190 Cloned: IDs, BARs, MSI-X\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502              Stable Core IP             \u2502 \u2190 Consistent across builds\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502        AXI-PCIe Bridge              \u2502 \u2502 \u2190 Single timing closure\n\u2502  \u2502  \u2022 TLP packet processing           \u2502 \u2502\n\u2502  \u2502  \u2022 Configuration space handler     \u2502 \u2502\n\u2502  \u2502  \u2022 Completion timeout logic        \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502        DMA Scatter-Gather           \u2502 \u2502 \u2190 Shared test benches\n\u2502  \u2502  \u2022 Descriptor ring management      \u2502 \u2502\n\u2502  \u2502  \u2022 Memory protection checks        \u2502 \u2502\n\u2502  \u2502  \u2022 Bandwidth throttling            \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502      Debug &amp; Monitoring             \u2502 \u2502 \u2190 Identical CSR map\n\u2502  \u2502  \u2022 UART/JTAG interfaces            \u2502 \u2502\n\u2502  \u2502  \u2022 Performance counters            \u2502 \u2502\n\u2502  \u2502  \u2022 ECC status registers            \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"firmware-uniqueness/#core-ip-benefits","title":"Core IP Benefits","text":"<ul> <li>Timing Closure: Single PLL domain, pre-verified timing constraints</li> <li>Test Coverage: Shared test benches across all device variants</li> <li>Debug Consistency: Identical register map for all builds</li> <li>Maintenance: Core updates propagate to all device types</li> </ul>"},{"location":"firmware-uniqueness/#performance-metrics","title":"Performance Metrics","text":""},{"location":"firmware-uniqueness/#resource-utilization","title":"Resource Utilization","text":"Metric Artix-7 35T Artix-7 75T Artix-7 100T Variation Notes Fmax 150 MHz 165 MHz 175 MHz \u00b15% Single PLL domain LUT Utilization 85% 45% 35% \u00b13% donor variance BAR decode depth only BRAM Usage 44 \u00d7 36Kb 44 \u00d7 36Kb 44 \u00d7 36Kb Fixed MSI-X tables + buffers DSP Slices 12 12 12 Fixed DMA checksum engines Static Power 180mW 200mW 220mW \u00b120mW Temperature dependent"},{"location":"firmware-uniqueness/#timing-analysis","title":"Timing Analysis","text":"<pre><code># Critical path constraints\ncreate_clock -period 6.667 -name pcie_clk [get_ports pcie_clk_p]\nset_input_delay -clock pcie_clk -max 2.0 [get_ports pcie_rx_p]\nset_output_delay -clock pcie_clk -max 2.0 [get_ports pcie_tx_p]\n\n# Cross-clock domain constraints\nset_clock_groups -asynchronous -group [get_clocks pcie_clk] -group [get_clocks user_clk]\n</code></pre>"},{"location":"firmware-uniqueness/#security-research-applications","title":"Security &amp; Research Applications","text":""},{"location":"firmware-uniqueness/#use-case-matrix","title":"Use Case Matrix","text":"Role Application Implementation Risk Mitigation Red Team Hardware implants, DMA attacks Covert data exfiltration via cloned capture cards Air-gapped testing, legal authorization Blue Team SIEM tuning, anomaly detection Generate realistic traffic without production risk Isolated lab networks, controlled scenarios Academia PCIe security research TLP poisoning, IOMMU bypass studies Ethical review, responsible disclosure Tool Vendors Legacy hardware validation Driver testing against discontinued hardware Licensing compliance, IP protection Forensics Evidence preservation Bit-perfect hardware replication for analysis Chain of custody, legal admissibility"},{"location":"firmware-uniqueness/#research-scenarios","title":"Research Scenarios","text":"<pre><code># Example: DMA attack simulation\nclass DMAAttackSimulator:\n    def __init__(self, target_device):\n        self.device = target_device\n        self.memory_map = self.scan_physical_memory()\n\n    def extract_credentials(self):\n        \"\"\"Simulate credential extraction via DMA\"\"\"\n        for region in self.memory_map:\n            if self.contains_sensitive_data(region):\n                yield self.extract_region(region)\n\n    def inject_payload(self, payload):\n        \"\"\"Simulate code injection via DMA writes\"\"\"\n        target_addr = self.find_executable_region()\n        return self.device.dma_write(target_addr, payload)\n</code></pre>"},{"location":"firmware-uniqueness/#troubleshooting-error-handling","title":"Troubleshooting &amp; Error Handling","text":""},{"location":"firmware-uniqueness/#common-issues-solutions","title":"Common Issues &amp; Solutions","text":""},{"location":"firmware-uniqueness/#build-time-errors","title":"Build-Time Errors","text":"Error Cause Solution Prevention Timing Closure Failure Complex donor BAR decode logic Reduce Fmax target, pipeline critical paths Pre-validate donor complexity Resource Overflow Large MSI-X tables on small FPGAs Use external memory for tables Check resource requirements early P&amp;R Failure IO pin conflicts Adjust pin assignments, use different package Validate pinout before synthesis"},{"location":"firmware-uniqueness/#runtime-issues","title":"Runtime Issues","text":"Symptom Likely Cause Diagnostic Steps Fix Code 10 Error Missing/incorrect capabilities Compare <code>lspci</code> output with donor Update capability chain IRQ Storm MSI-X table corruption Check interrupt vectors with <code>/proc/interrupts</code> Rebuild MSI-X configuration DMA Timeout Incorrect BAR mapping Verify memory regions with <code>/proc/iomem</code> Fix BAR size/alignment Link Training Failure PCIe electrical issues Check link status with <code>setpci</code> Verify signal integrity"},{"location":"firmware-uniqueness/#debug-infrastructure","title":"Debug Infrastructure","text":"<pre><code>// Integrated debug features\nmodule debug_controller (\n    input wire clk,\n    input wire rst_n,\n\n    // Debug interfaces\n    output wire [31:0] debug_status,\n    output wire [63:0] error_counters,\n    input wire [31:0] debug_control,\n\n    // UART debug output\n    output wire uart_tx,\n    input wire uart_rx\n);\n\n// Performance monitoring\nalways @(posedge clk) begin\n    if (!rst_n) begin\n        pcie_tlp_count &lt;= 0;\n        dma_transfer_count &lt;= 0;\n        error_count &lt;= 0;\n    end else begin\n        if (tlp_valid) pcie_tlp_count &lt;= pcie_tlp_count + 1;\n        if (dma_done) dma_transfer_count &lt;= dma_transfer_count + 1;\n        if (error_detected) error_count &lt;= error_count + 1;\n    end\nend\n</code></pre>"},{"location":"firmware-uniqueness/#best-practices","title":"Best Practices","text":""},{"location":"firmware-uniqueness/#development-workflow","title":"Development Workflow","text":"<ol> <li>Donor Analysis: Thoroughly characterize donor device before cloning</li> <li>Incremental Testing: Validate each capability block individually</li> <li>Regression Testing: Maintain test suite for all supported donors</li> <li>Version Control: Tag bitstreams with donor fingerprints</li> <li>Documentation: Maintain detailed build logs and test results</li> </ol>"},{"location":"firmware-uniqueness/#security-considerations","title":"Security Considerations","text":"<ul> <li>Isolation: Test in air-gapped environments</li> <li>Backup: Always preserve original donor firmware</li> <li>Validation: Verify cloned behavior matches donor exactly</li> <li>Monitoring: Log all device interactions for analysis</li> <li>Updates: Regularly update against new detection methods</li> </ul>"},{"location":"firmware-uniqueness/#legal-ethical-considerations","title":"Legal &amp; Ethical Considerations","text":""},{"location":"firmware-uniqueness/#critical-warnings","title":"\u26a0\ufe0f Critical Warnings","text":"Risk Category Concern Mitigation Legal Compliance Hardware impersonation may violate local laws Consult legal counsel, obtain proper authorization Network Security Unauthorized device deployment Use only in authorized test environments Intellectual Property Donor firmware may be copyrighted Respect vendor IP rights, fair use only Safety Malformed firmware can damage hardware Maintain serial console access, backup procedures"},{"location":"firmware-uniqueness/#responsible-use-guidelines","title":"Responsible Use Guidelines","text":"<ul> <li>Authorization: Obtain explicit permission before deploying on any network</li> <li>Disclosure: Follow responsible disclosure for security vulnerabilities</li> <li>Documentation: Maintain detailed logs of all testing activities</li> <li>Isolation: Use dedicated test hardware and networks</li> <li>Backup: Always preserve original firmware before modifications</li> </ul>"},{"location":"firmware-uniqueness/#emergency-procedures","title":"Emergency Procedures","text":"<pre><code>#!/bin/bash\n# Emergency recovery procedures\n\necho \"=== Emergency Recovery ===\"\n\n# Restore original firmware\nif [ -f \"donor_backup.bin\" ]; then\n    echo \"Restoring donor firmware...\"\n    flashrom -p internal -w donor_backup.bin\nfi\n\n# Reset PCIe subsystem\necho \"Resetting PCIe...\"\necho 1 &gt; /sys/bus/pci/devices/$DEVICE_BDF/remove\necho 1 &gt; /sys/bus/pci/rescan\n\n# Check system stability\ndmesg | tail -20\n</code></pre>"},{"location":"firmware-uniqueness/#conclusion","title":"Conclusion","text":"<p>The PCILeech firmware generator provides a robust foundation for security research and hardware analysis through authentic device cloning. By maintaining perfect external compatibility while ensuring internal consistency, it enables safe, reproducible testing scenarios that would be impossible with original hardware.</p> <p>Key Takeaways:</p> <ul> <li>Byte-perfect cloning ensures undetectable operation</li> <li>Immutable core architecture provides build consistency  </li> <li>Comprehensive validation prevents deployment issues</li> <li>Responsible use requires proper authorization and safety measures</li> </ul>"},{"location":"installation/","title":"Installation Guide","text":"<p>This guide will walk you through installing the PCILeech Firmware Generator on your system.</p>"},{"location":"installation/#system-requirements","title":"System Requirements","text":""},{"location":"installation/#operating-system","title":"Operating System","text":"<ul> <li>Linux: Ubuntu 20.04+ (recommended), Debian 11+, RHEL 8+, or similar</li> <li>Python: 3.8 or higher</li> <li>Memory: 4GB RAM minimum, 8GB recommended for complex devices</li> <li>Storage: 2GB free space for FPGA tools and generated firmware</li> </ul>"},{"location":"installation/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>FPGA Development Board: Supported Xilinx board (see Supported Devices)</li> <li>Donor PCIe Device: Any standard PCIe device for configuration extraction</li> <li>USB-JTAG Programmer: For optional FPGA programming (Xilinx Platform Cable or compatible)</li> </ul>"},{"location":"installation/#installation-methods","title":"Installation Methods","text":""},{"location":"installation/#method-1-install-from-pypi-recommended","title":"Method 1: Install from PyPI (Recommended)","text":"<pre><code># Install the latest stable release\npip install pcileech-fw-generator\n\n# Verify installation\npcileech-generate --version\n</code></pre>"},{"location":"installation/#method-2-install-from-source","title":"Method 2: Install from Source","text":"<pre><code># Clone the repository\ngit clone https://github.com/ramseymcgrath/PCILeechFWGenerator.git\ncd PCILeechFWGenerator\n\n# Create virtual environment (recommended)\npython3 -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install in development mode\npip install -e .\n\n# Or install normally\npip install .\n</code></pre>"},{"location":"installation/#method-3-using-dockerpodman","title":"Method 3: Using Docker/Podman","text":"<pre><code># Pull the container image\ndocker pull ghcr.io/ramseymcgrath/pcileechfwgenerator:latest\n\n# Run with current directory mounted\ndocker run -it --rm \\\n  -v $(pwd):/workspace \\\n  -v /dev:/dev \\\n  --privileged \\\n  ghcr.io/ramseymcgrath/pcileechfwgenerator:latest\n</code></pre>"},{"location":"installation/#vfio-setup","title":"VFIO Setup","text":"<p>The generator requires VFIO drivers to access donor devices. Here's how to set them up:</p>"},{"location":"installation/#1-enable-iommu","title":"1. Enable IOMMU","text":"<p>Add to your kernel command line (usually in <code>/etc/default/grub</code>):</p> <pre><code># For Intel CPUs\nGRUB_CMDLINE_LINUX=\"intel_iommu=on iommu=pt\"\n\n# For AMD CPUs\nGRUB_CMDLINE_LINUX=\"amd_iommu=on iommu=pt\"\n</code></pre> <p>Update GRUB and reboot:</p> <pre><code>sudo update-grub\nsudo reboot\n</code></pre>"},{"location":"installation/#2-load-vfio-modules","title":"2. Load VFIO Modules","text":"<pre><code># Load required modules\nsudo modprobe vfio-pci\nsudo modprobe vfio-iommu-type1\n\n# Make persistent (add to /etc/modules)\necho \"vfio-pci\" | sudo tee -a /etc/modules\necho \"vfio-iommu-type1\" | sudo tee -a /etc/modules\n</code></pre>"},{"location":"installation/#3-bind-device-to-vfio","title":"3. Bind Device to VFIO","text":"<p>Find your device:</p> <pre><code># List PCIe devices\nlspci -nn\n\n# Example output:\n# 01:00.0 Ethernet controller [0200]: Intel Corporation 82599ES [8086:10fb]\n</code></pre> <p>Bind to VFIO:</p> <pre><code># Replace with your device ID and vendor:device codes\necho \"8086 10fb\" | sudo tee /sys/bus/pci/drivers/vfio-pci/new_id\necho \"0000:01:00.0\" | sudo tee /sys/bus/pci/devices/0000:01:00.0/driver/unbind\necho \"0000:01:00.0\" | sudo tee /sys/bus/pci/drivers/vfio-pci/bind\n</code></pre>"},{"location":"installation/#xilinx-vivado-setup-optional","title":"Xilinx Vivado Setup (Optional)","text":"<p>For FPGA synthesis and programming, install Xilinx Vivado:</p>"},{"location":"installation/#1-download-vivado","title":"1. Download Vivado","text":"<ul> <li>Visit Xilinx Downloads</li> <li>Download Vivado ML Edition (2020.1 or later)</li> <li>Choose WebPACK (free) or Standard/Enterprise edition</li> </ul>"},{"location":"installation/#2-install-vivado","title":"2. Install Vivado","text":"<pre><code># Extract and run installer\ntar -xvf Xilinx_Unified_*.tar.gz\ncd Xilinx_Unified_*/\nsudo ./xsetup\n</code></pre>"},{"location":"installation/#3-setup-environment","title":"3. Setup Environment","text":"<p>Add to your <code>~/.bashrc</code> or <code>~/.zshrc</code>:</p> <pre><code># Xilinx Vivado\nsource /opt/Xilinx/Vivado/2023.1/settings64.sh  # Adjust version\nexport PATH=$PATH:/opt/Xilinx/Vivado/2023.1/bin\n</code></pre>"},{"location":"installation/#usb-jtag-driver-setup-optional","title":"USB-JTAG Driver Setup (Optional)","text":"<p>For programming FPGAs via USB-JTAG:</p>"},{"location":"installation/#1-install-cable-drivers","title":"1. Install Cable Drivers","text":"<pre><code># For Xilinx Platform Cable\ncd /opt/Xilinx/Vivado/2023.1/data/xicom/cable_drivers/lin64/install_script/install_drivers\nsudo ./install_drivers\n\n# For Digilent cables\nwget https://github.com/Digilent/digilent.adept.runtime/releases/download/v2.27.9/digilent.adept.runtime_2.27.9-amd64.deb\nsudo dpkg -i digilent.adept.runtime_2.27.9-amd64.deb\n</code></pre>"},{"location":"installation/#2-setup-udev-rules","title":"2. Setup udev Rules","text":"<p>Create <code>/etc/udev/rules.d/52-xilinx-ftdi-usb.rules</code>:</p> <pre><code># Xilinx USB cables\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6010\", GROUP=\"plugdev\"\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0403\", ATTRS{idProduct}==\"6014\", GROUP=\"plugdev\"\n\n# Digilent cables\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"1443\", GROUP=\"plugdev\"\n</code></pre> <p>Reload udev rules:</p> <pre><code>sudo udevadm control --reload-rules\nsudo udevadm trigger\n</code></pre>"},{"location":"installation/#verification","title":"Verification","text":"<p>Verify your installation:</p> <pre><code># Check basic installation\npcileech-generate --help\n\n# Check VFIO access (requires bound device)\npcileech-generate --list-devices\n\n# Check Vivado integration (if installed)\npcileech-generate --check-tools\n\n# Run self-test\npcileech-generate --self-test\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":""},{"location":"installation/#permission-denied","title":"Permission Denied","text":"<pre><code># Add user to vfio group\nsudo usermod -a -G vfio $USER\n\n# Add user to plugdev group (for USB-JTAG)\nsudo usermod -a -G plugdev $USER\n\n# Logout and login again\n</code></pre>"},{"location":"installation/#iommu-not-available","title":"IOMMU Not Available","text":"<pre><code># Check IOMMU status\ndmesg | grep -i iommu\n\n# Verify kernel command line\ncat /proc/cmdline\n</code></pre>"},{"location":"installation/#device-not-found","title":"Device Not Found","text":"<pre><code># Check device binding\nls -la /sys/bus/pci/drivers/vfio-pci/\n\n# Check IOMMU groups\nfind /sys/kernel/iommu_groups/ -type l\n</code></pre>"},{"location":"installation/#vivado-not-found","title":"Vivado Not Found","text":"<pre><code># Check Vivado installation\nwhich vivado\n\n# Source Vivado settings\nsource /opt/Xilinx/Vivado/*/settings64.sh\n</code></pre>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the Troubleshooting Guide</li> <li>Review the FAQ</li> <li>Search existing GitHub Issues</li> <li>Join our Discord Community</li> <li>Create a new issue with detailed logs and system information</li> </ol>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<p>Once installation is complete:</p> <ol> <li>Quick Start Guide: Generate your first firmware</li> <li>Device Cloning: Learn about device extraction</li> <li>Development Guide: Contributing to the project</li> </ol> <p>Ready to generate firmware? Continue to the Quick Start Guide!</p>"},{"location":"manual-donor-dump/","title":"Manual Donor Dump","text":""},{"location":"manual-donor-dump/#overview","title":"Overview","text":""},{"location":"manual-donor-dump/#what-is-a-donor-dump","title":"What is a Donor Dump?","text":"<p>A donor dump is a comprehensive snapshot of a physical PCI device's configuration and capabilities. The PCILeech Firmware Generator uses this information to create firmware that accurately emulates the donor device's behavior.</p> <p>Key Information Captured:</p> Component Description Purpose Device Identity Vendor/Device IDs, Subsystem IDs, Revision Device identification and driver matching Configuration Space Full 4KB extended PCI configuration Complete device state and capabilities Power Management MPC/MPR values, power states Power efficiency and compatibility Capabilities AER, MSI/MSI-X, vendor-specific Advanced PCI features Memory Layout BAR sizes, Device Serial Number (DSN) Memory mapping and addressing Class Information 24-bit class code Device type classification"},{"location":"manual-donor-dump/#when-to-use-manual-process","title":"When to Use Manual Process","text":"<ul> <li>Debugging: When automated tools fail or produce unexpected results</li> <li>Custom Workflows: Integration with existing automation or CI/CD pipelines</li> <li>Research: Understanding the donor extraction process in detail</li> <li>Troubleshooting: Isolating issues in the firmware generation pipeline</li> </ul>"},{"location":"manual-donor-dump/#prerequisites","title":"Prerequisites","text":""},{"location":"manual-donor-dump/#system-requirements","title":"System Requirements","text":"Requirement Linux OS Version Any modern distribution Privileges Root access (<code>sudo</code>) Shell Bash/Zsh Build Tools GCC, Make, Kernel Headers"},{"location":"manual-donor-dump/#quick-prerequisite-check","title":"Quick Prerequisite Check","text":"<p>Linux: <pre><code># Check if all prerequisites are available\necho \"Checking prerequisites...\"\ncommand -v gcc &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo \"\u2713 GCC available\" || echo \"\u2717 GCC missing\"\ncommand -v make &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo \"\u2713 Make available\" || echo \"\u2717 Make missing\"\n[ -d \"/lib/modules/$(uname -r)/build\" ] &amp;&amp; echo \"\u2713 Kernel headers available\" || echo \"\u2717 Kernel headers missing\"\n[ \"$EUID\" -eq 0 ] &amp;&amp; echo \"\u2713 Running as root\" || echo \"\u2717 Need root privileges\"\n</code></pre></p>"},{"location":"manual-donor-dump/#installing-prerequisites","title":"Installing Prerequisites","text":""},{"location":"manual-donor-dump/#debianubuntu","title":"Debian/Ubuntu","text":"<pre><code>sudo apt-get update &amp;&amp; sudo apt-get install -y \\\n    linux-headers-$(uname -r) \\\n    build-essential \\\n    dkms\n</code></pre>"},{"location":"manual-donor-dump/#fedoracentosrhel","title":"Fedora/CentOS/RHEL","text":"<pre><code>sudo dnf install -y \\\n    kernel-devel-$(uname -r) \\\n    gcc \\\n    make \\\n    dkms\n</code></pre>"},{"location":"manual-donor-dump/#arch-linuxmanjaro","title":"Arch Linux/Manjaro","text":"<pre><code>sudo pacman -S --needed \\\n    linux-headers \\\n    base-devel \\\n    dkms\n</code></pre>"},{"location":"manual-donor-dump/#opensuse","title":"openSUSE","text":"<pre><code>sudo zypper install -y \\\n    kernel-devel-$(uname -r) \\\n    gcc \\\n    make \\\n    dkms\n</code></pre>"},{"location":"manual-donor-dump/#linux-manual-process","title":"Linux Manual Process","text":""},{"location":"manual-donor-dump/#step-1-device-discovery-and-validation","title":"Step 1: Device Discovery and Validation","text":""},{"location":"manual-donor-dump/#find-your-donor-device","title":"Find Your Donor Device","text":"<pre><code># List all PCI devices with detailed information\nlspci -vv\n\n# Filter by device type (example: network controllers)\nlspci -vv | grep -A 20 \"Ethernet controller\"\n\n# Get specific device information\nlspci -s 03:00.0 -vv\n</code></pre>"},{"location":"manual-donor-dump/#validate-device-accessibility","title":"Validate Device Accessibility","text":"<pre><code># Check if device is bound to a driver\nlspci -k -s 03:00.0\n\n# Verify device is not in use by critical services\nsystemctl status NetworkManager  # For network devices\nsystemctl status display-manager # For graphics devices\n</code></pre>"},{"location":"manual-donor-dump/#extract-bdf-information","title":"Extract BDF Information","text":"<pre><code># Get BDF with domain information\nDEVICE_BDF=$(lspci | grep \"Ethernet controller\" | head -1 | cut -d' ' -f1)\nFULL_BDF=\"0000:${DEVICE_BDF}\"\necho \"Using device: ${FULL_BDF}\"\n</code></pre>"},{"location":"manual-donor-dump/#step-2-build-environment-setup","title":"Step 2: Build Environment Setup","text":""},{"location":"manual-donor-dump/#navigate-to-build-directory","title":"Navigate to Build Directory","text":"<pre><code># Ensure we're in the correct directory\ncd \"$(dirname \"$0\")/../PCILeechFWGenerator/src/donor_dump\" || {\n    echo \"Error: Cannot find donor_dump directory\"\n    exit 1\n}\n\n# Verify required files exist\n[ -f \"Makefile\" ] || { echo \"Error: Makefile not found\"; exit 1; }\n[ -f \"donor_dump.c\" ] || { echo \"Error: Source file not found\"; exit 1; }\n</code></pre>"},{"location":"manual-donor-dump/#clean-build-environment","title":"Clean Build Environment","text":"<pre><code># Clean any previous builds\nmake clean\n\n# Verify kernel build environment\nmake -n 2&gt;&amp;1 | grep -q \"No rule to make target\" &amp;&amp; {\n    echo \"Error: Kernel build environment not properly configured\"\n    exit 1\n}\n</code></pre>"},{"location":"manual-donor-dump/#build-with-error-handling","title":"Build with Error Handling","text":"<pre><code># Build the kernel module with verbose output\nif ! make V=1; then\n    echo \"Build failed. Common issues:\"\n    echo \"1. Kernel headers mismatch: $(uname -r) vs $(ls /lib/modules/)\"\n    echo \"2. Missing dependencies: gcc, make, kernel-devel\"\n    echo \"3. Insufficient permissions\"\n    exit 1\nfi\n\n# Verify build artifacts\n[ -f \"donor_dump.ko\" ] || { echo \"Error: Module not built\"; exit 1; }\necho \"\u2713 Module built successfully: $(ls -lh donor_dump.ko)\"\n</code></pre>"},{"location":"manual-donor-dump/#step-3-module-loading-and-device-binding","title":"Step 3: Module Loading and Device Binding","text":""},{"location":"manual-donor-dump/#pre-load-validation","title":"Pre-load Validation","text":"<pre><code># Check if module is already loaded\nif lsmod | grep -q donor_dump; then\n    echo \"Warning: donor_dump module already loaded\"\n    sudo rmmod donor_dump || {\n        echo \"Error: Cannot unload existing module\"\n        exit 1\n    }\nfi\n\n# Verify device exists and is accessible\nif ! lspci -s \"${DEVICE_BDF}\" &gt;/dev/null 2&gt;&amp;1; then\n    echo \"Error: Device ${FULL_BDF} not found\"\n    exit 1\nfi\n</code></pre>"},{"location":"manual-donor-dump/#load-module-with-comprehensive-error-handling","title":"Load Module with Comprehensive Error Handling","text":"<pre><code># Load module with device binding\nif ! sudo insmod donor_dump.ko bdf=\"${FULL_BDF}\"; then\n    echo \"Module load failed. Checking kernel logs...\"\n    dmesg | tail -20 | grep donor_dump\n    exit 1\nfi\n\n# Verify module loaded successfully\nif ! lsmod | grep -q donor_dump; then\n    echo \"Error: Module not loaded despite successful insmod\"\n    exit 1\nfi\n\necho \"\u2713 Module loaded successfully for device ${FULL_BDF}\"\n</code></pre>"},{"location":"manual-donor-dump/#verify-proc-interface","title":"Verify Proc Interface","text":"<pre><code># Check if proc file is created and accessible\nif [ ! -r \"/proc/donor_dump\" ]; then\n    echo \"Error: /proc/donor_dump not accessible\"\n    echo \"Module may have loaded but device binding failed\"\n    sudo rmmod donor_dump\n    exit 1\nfi\n\necho \"\u2713 Proc interface available\"\n</code></pre>"},{"location":"manual-donor-dump/#step-4-data-extraction-and-validation","title":"Step 4: Data Extraction and Validation","text":""},{"location":"manual-donor-dump/#extract-raw-data","title":"Extract Raw Data","text":"<pre><code># Read donor information with error checking\nif ! DONOR_DATA=$(cat /proc/donor_dump 2&gt;/dev/null); then\n    echo \"Error: Cannot read donor information\"\n    sudo rmmod donor_dump\n    exit 1\nfi\n\n# Validate data completeness\nif [ -z \"$DONOR_DATA\" ]; then\n    echo \"Error: No donor data extracted\"\n    sudo rmmod donor_dump\n    exit 1\nfi\n\necho \"\u2713 Donor data extracted ($(echo \"$DONOR_DATA\" | wc -l) lines)\"\n</code></pre>"},{"location":"manual-donor-dump/#save-raw-data-with-metadata","title":"Save Raw Data with Metadata","text":"<pre><code># Create output directory with timestamp\nOUTPUT_DIR=\"donor_dumps/$(date +%Y%m%d_%H%M%S)_${DEVICE_BDF//:/_}\"\nmkdir -p \"$OUTPUT_DIR\"\n\n# Save raw data with metadata\n{\n    echo \"# Donor dump generated on $(date)\"\n    echo \"# Device: ${FULL_BDF}\"\n    echo \"# Kernel: $(uname -r)\"\n    echo \"# System: $(uname -a)\"\n    echo \"\"\n    echo \"$DONOR_DATA\"\n} &gt; \"${OUTPUT_DIR}/donor_info.txt\"\n\necho \"\u2713 Raw data saved to ${OUTPUT_DIR}/donor_info.txt\"\n</code></pre>"},{"location":"manual-donor-dump/#convert-to-json-with-validation","title":"Convert to JSON with Validation","text":"<pre><code># Enhanced JSON conversion with validation\nconvert_to_json() {\n    local input_file=\"$1\"\n    local output_file=\"$2\"\n\n    # Create JSON with proper escaping and validation\n    {\n        echo \"{\"\n        echo \"  \\\"metadata\\\": {\"\n        echo \"    \\\"generated_at\\\": \\\"$(date -Iseconds)\\\",\"\n        echo \"    \\\"device_bdf\\\": \\\"${FULL_BDF}\\\",\"\n        echo \"    \\\"kernel_version\\\": \\\"$(uname -r)\\\",\"\n        echo \"    \\\"generator_version\\\": \\\"manual-v1.0\\\"\"\n        echo \"  },\"\n        echo \"  \\\"device_info\\\": {\"\n\n        # Process each line, handling special characters\n        grep -v '^#' \"$input_file\" | while IFS=':' read -r key value; do\n            if [ -n \"$key\" ] &amp;&amp; [ -n \"$value\" ]; then\n                # Escape special characters in JSON\n                key=$(echo \"$key\" | sed 's/\"/\\\\\"/g' | xargs)\n                value=$(echo \"$value\" | sed 's/\"/\\\\\"/g' | xargs)\n                echo \"    \\\"$key\\\": \\\"$value\\\",\"\n            fi\n        done | sed '$ s/,$//'  # Remove trailing comma\n\n        echo \"  }\"\n        echo \"}\"\n    } &gt; \"$output_file\"\n\n    # Validate JSON syntax\n    if command -v python3 &gt;/dev/null 2&gt;&amp;1; then\n        if ! python3 -m json.tool \"$output_file\" &gt;/dev/null 2&gt;&amp;1; then\n            echo \"Warning: Generated JSON may be invalid\"\n            return 1\n        fi\n    fi\n\n    return 0\n}\n\n# Convert to JSON\nJSON_FILE=\"${OUTPUT_DIR}/donor_info.json\"\nif convert_to_json \"${OUTPUT_DIR}/donor_info.txt\" \"$JSON_FILE\"; then\n    echo \"\u2713 JSON file created: $JSON_FILE\"\nelse\n    echo \"\u26a0 JSON conversion completed with warnings\"\nfi\n</code></pre>"},{"location":"manual-donor-dump/#step-5-cleanup-and-verification","title":"Step 5: Cleanup and Verification","text":""},{"location":"manual-donor-dump/#safe-module-unloading","title":"Safe Module Unloading","text":"<pre><code># Unload module with verification\ncleanup_module() {\n    if lsmod | grep -q donor_dump; then\n        if sudo rmmod donor_dump; then\n            echo \"\u2713 Module unloaded successfully\"\n        else\n            echo \"Warning: Module unload failed\"\n            echo \"Check: lsmod | grep donor_dump\"\n            echo \"Force remove: sudo rmmod -f donor_dump\"\n        fi\n    fi\n}\n\n# Set trap for cleanup on script exit\ntrap cleanup_module EXIT\n</code></pre>"},{"location":"manual-donor-dump/#verify-output-quality","title":"Verify Output Quality","text":"<pre><code># Comprehensive output validation\nvalidate_donor_dump() {\n    local json_file=\"$1\"\n\n    echo \"Validating donor dump quality...\"\n\n    # Check required fields\n    local required_fields=(\"vendor_id\" \"device_id\" \"class_code\")\n    for field in \"${required_fields[@]}\"; do\n        if ! grep -q \"\\\"$field\\\"\" \"$json_file\"; then\n            echo \"Warning: Missing required field: $field\"\n        fi\n    done\n\n    # Check file size (should be reasonable)\n    local file_size=$(stat -f%z \"$json_file\" 2&gt;/dev/null || stat -c%s \"$json_file\" 2&gt;/dev/null)\n    if [ \"$file_size\" -lt 100 ]; then\n        echo \"Warning: Donor dump seems too small ($file_size bytes)\"\n    elif [ \"$file_size\" -gt 10000 ]; then\n        echo \"Warning: Donor dump seems unusually large ($file_size bytes)\"\n    else\n        echo \"\u2713 Donor dump size looks reasonable ($file_size bytes)\"\n    fi\n}\n\nvalidate_donor_dump \"$JSON_FILE\"\n</code></pre>"},{"location":"manual-donor-dump/#validation-and-testing","title":"Validation and Testing","text":""},{"location":"manual-donor-dump/#donor-dump-quality-validation","title":"Donor Dump Quality Validation","text":""},{"location":"manual-donor-dump/#comprehensive-validation-script","title":"Comprehensive Validation Script","text":"<pre><code>#!/bin/bash\n# validate_donor_dump.sh - Comprehensive donor dump validation\n\nvalidate_donor_dump() {\n    local json_file=\"$1\"\n    local errors=0\n    local warnings=0\n\n    echo \"=== Donor Dump Validation Report ===\"\n    echo \"File: $json_file\"\n    echo \"Generated: $(date)\"\n    echo \"\"\n\n    # Check file existence and readability\n    if [ ! -f \"$json_file\" ]; then\n        echo \"\u274c ERROR: File does not exist\"\n        return 1\n    fi\n\n    if [ ! -r \"$json_file\" ]; then\n        echo \"\u274c ERROR: File is not readable\"\n        return 1\n    fi\n\n    # Validate JSON syntax\n    if command -v jq &gt;/dev/null 2&gt;&amp;1; then\n        if ! jq empty \"$json_file\" 2&gt;/dev/null; then\n            echo \"\u274c ERROR: Invalid JSON syntax\"\n            ((errors++))\n        else\n            echo \"\u2713 JSON syntax valid\"\n        fi\n    else\n        echo \"\u26a0 WARNING: jq not available, skipping JSON validation\"\n        ((warnings++))\n    fi\n\n    # Check required fields\n    local required_fields=(\n        \".device_info.vendor_id\"\n        \".device_info.device_id\"\n        \".metadata.device_bdf\"\n    )\n\n    for field in \"${required_fields[@]}\"; do\n        if command -v jq &gt;/dev/null 2&gt;&amp;1; then\n            if [ \"$(jq -r \"$field // empty\" \"$json_file\")\" = \"\" ]; then\n                echo \"\u274c ERROR: Missing required field: $field\"\n                ((errors++))\n            else\n                echo \"\u2713 Required field present: $field\"\n            fi\n        fi\n    done\n\n    # Validate field formats\n    if command -v jq &gt;/dev/null 2&gt;&amp;1; then\n        # Check vendor_id format (4 hex digits)\n        vendor_id=$(jq -r '.device_info.vendor_id // empty' \"$json_file\")\n        if [[ ! \"$vendor_id\" =~ ^[0-9A-Fa-f]{4}$ ]]; then\n            echo \"\u274c ERROR: Invalid vendor_id format: $vendor_id\"\n            ((errors++))\n        fi\n\n        # Check device_id format (4 hex digits)\n        device_id=$(jq -r '.device_info.device_id // empty' \"$json_file\")\n        if [[ ! \"$device_id\" =~ ^[0-9A-Fa-f]{4}$ ]]; then\n            echo \"\u274c ERROR: Invalid device_id format: $device_id\"\n            ((errors++))\n        fi\n\n        # Check BDF format\n        bdf=$(jq -r '.metadata.device_bdf // empty' \"$json_file\")\n        if [[ ! \"$bdf\" =~ ^[0-9A-Fa-f]{4}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}\\.[0-9A-Fa-f]$ ]]; then\n            echo \"\u26a0 WARNING: Unusual BDF format: $bdf\"\n            ((warnings++))\n        fi\n    fi\n\n    # File size checks\n    local file_size=$(stat -f%z \"$json_file\" 2&gt;/dev/null || stat -c%s \"$json_file\" 2&gt;/dev/null)\n    if [ \"$file_size\" -lt 200 ]; then\n        echo \"\u26a0 WARNING: File seems small ($file_size bytes) - may be incomplete\"\n        ((warnings++))\n    elif [ \"$file_size\" -gt 50000 ]; then\n        echo \"\u26a0 WARNING: File seems large ($file_size bytes) - may contain unexpected data\"\n        ((warnings++))\n    fi\n\n    echo \"\"\n    echo \"=== Validation Summary ===\"\n    echo \"Errors: $errors\"\n    echo \"Warnings: $warnings\"\n\n    if [ \"$errors\" -eq 0 ]; then\n        echo \"\u2705 Validation PASSED\"\n        return 0\n    else\n        echo \"\u274c Validation FAILED\"\n        return 1\n    fi\n}\n\n# Usage: validate_donor_dump \"path/to/donor_info.json\"\n</code></pre>"},{"location":"manual-donor-dump/#integration-testing","title":"Integration Testing","text":""},{"location":"manual-donor-dump/#test-with-pcileech-generator","title":"Test with PCILeech Generator","text":"<pre><code>#!/bin/bash\n# test_donor_integration.sh - Test donor dump with PCILeech\n\ntest_donor_integration() {\n    local donor_file=\"$1\"\n    local test_board=\"${2:-pcileech_35t325_x1}\"\n    local test_bdf=\"${3:-0000:03:00.0}\"\n\n    echo \"Testing donor dump integration...\"\n\n    # Validate donor file first\n    if ! validate_donor_dump \"$donor_file\"; then\n        echo \"\u274c Donor dump validation failed\"\n        return 1\n    fi\n\n    # Test dry-run with PCILeech generator\n    if command -v pcileech-generate &gt;/dev/null 2&gt;&amp;1; then\n        echo \"Testing with PCILeech generator (dry-run)...\"\n        if pcileech-generate \\\n            --bdf \"$test_bdf\" \\\n            --board \"$test_board\" \\\n            --donor-info-file \"$donor_file\" \\\n            --dry-run; then\n            echo \"\u2705 Integration test PASSED\"\n            return 0\n        else\n            echo \"\u274c Integration test FAILED\"\n            return 1\n        fi\n    else\n        echo \"\u26a0 PCILeech generator not available, skipping integration test\"\n        return 0\n    fi\n}\n</code></pre>"},{"location":"manual-donor-dump/#troubleshooting","title":"Troubleshooting","text":""},{"location":"manual-donor-dump/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"manual-donor-dump/#linux-specific-issues","title":"Linux-Specific Issues","text":"<p>1. Kernel Headers Mismatch <pre><code># Problem: Headers don't match running kernel\n# Solution: Install correct headers or use DKMS\n\n# Check current kernel vs available headers\necho \"Running kernel: $(uname -r)\"\necho \"Available headers:\"\nls /lib/modules/*/build 2&gt;/dev/null || echo \"No headers found\"\n\n# Fix with DKMS (recommended)\nsudo apt-get install dkms\nsudo dkms add ./donor_dump\nsudo dkms build donor_dump/1.0\nsudo dkms install donor_dump/1.0\n</code></pre></p> <p>2. Module Loading Failures <pre><code># Comprehensive module debugging\ndebug_module_load() {\n    local module_path=\"$1\"\n    local bdf=\"$2\"\n\n    echo \"Debugging module load for $module_path with BDF $bdf\"\n\n    # Check module dependencies\n    echo \"Module info:\"\n    modinfo \"$module_path\"\n\n    # Check for conflicting modules\n    echo \"Checking for conflicts:\"\n    lsmod | grep -E \"(pci|donor)\"\n\n    # Attempt load with verbose logging\n    echo \"Loading with verbose logging:\"\n    sudo insmod \"$module_path\" bdf=\"$bdf\" debug=1\n\n    # Check kernel logs\n    echo \"Recent kernel messages:\"\n    dmesg | tail -20\n}\n</code></pre></p> <p>3. Device Access Issues <pre><code># Check device binding and driver conflicts\ncheck_device_binding() {\n    local bdf=\"$1\"\n\n    echo \"Device binding status for $bdf:\"\n\n    # Check current driver\n    if [ -d \"/sys/bus/pci/devices/$bdf\" ]; then\n        echo \"Device exists in sysfs\"\n\n        if [ -L \"/sys/bus/pci/devices/$bdf/driver\" ]; then\n            current_driver=$(readlink \"/sys/bus/pci/devices/$bdf/driver\" | xargs basename)\n            echo \"Current driver: $current_driver\"\n\n            # Suggest unbinding if necessary\n            echo \"To unbind: echo '$bdf' | sudo tee /sys/bus/pci/devices/$bdf/driver/unbind\"\n        else\n            echo \"No driver bound\"\n        fi\n    else\n        echo \"\u274c Device not found in sysfs\"\n    fi\n}\n</code></pre></p>"},{"location":"manual-donor-dump/#performance-optimization","title":"Performance Optimization","text":""},{"location":"manual-donor-dump/#batch-processing-multiple-devices","title":"Batch Processing Multiple Devices","text":"<pre><code>#!/bin/bash\n# batch_donor_dump.sh - Process multiple devices efficiently\n\nbatch_donor_dump() {\n    local device_list=\"$1\"  # File with one BDF per line\n    local output_dir=\"$2\"\n\n    mkdir -p \"$output_dir\"\n\n    # Build module once\n    echo \"Building donor_dump module...\"\n    if ! make -C src/donor_dump; then\n        echo \"\u274c Module build failed\"\n        return 1\n    fi\n\n    # Process each device\n    while IFS= read -r bdf; do\n        [ -z \"$bdf\" ] &amp;&amp; continue\n        [[ \"$bdf\" =~ ^#.*$ ]] &amp;&amp; continue  # Skip comments\n\n        echo \"Processing device: $bdf\"\n\n        # Create device-specific output directory\n        device_dir=\"$output_dir/${bdf//:/_}\"\n        mkdir -p \"$device_dir\"\n\n        # Load module for this device\n        if sudo insmod src/donor_dump/donor_dump.ko bdf=\"$bdf\"; then\n            # Extract data\n            cat /proc/donor_dump &gt; \"$device_dir/donor_info.txt\"\n\n            # Convert to JSON\n            convert_to_json \"$device_dir/donor_info.txt\" \"$device_dir/donor_info.json\"\n\n            # Unload module\n            sudo rmmod donor_dump\n\n            echo \"\u2713 Completed: $bdf\"\n        else\n            echo \"\u274c Failed: $bdf\"\n        fi\n\n        # Brief pause to avoid overwhelming the system\n        sleep 1\n    done &lt; \"$device_list\"\n}\n</code></pre>"},{"location":"manual-donor-dump/#advanced-usage","title":"Advanced Usage","text":""},{"location":"manual-donor-dump/#custom-data-extraction","title":"Custom Data Extraction","text":""},{"location":"manual-donor-dump/#extended-information-gathering","title":"Extended Information Gathering","text":"<pre><code># Enhanced donor dump with additional system context\ncreate_extended_donor_dump() {\n    local bdf=\"$1\"\n    local output_file=\"$2\"\n\n    # Standard donor dump\n    cat /proc/donor_dump &gt; \"${output_file}.raw\"\n\n    # Add system context\n    {\n        echo \"=== EXTENDED DONOR DUMP ===\"\n        echo \"Generated: $(date -Iseconds)\"\n        echo \"System: $(uname -a)\"\n        echo \"BDF: $bdf\"\n        echo \"\"\n\n        echo \"=== DEVICE INFORMATION ===\"\n        lspci -vvv -s \"${bdf#0000:}\"\n        echo \"\"\n\n        echo \"=== SYSTEM PCI TREE ===\"\n        lspci -tv\n        echo \"\"\n\n        echo \"=== IOMMU GROUPS ===\"\n        find /sys/kernel/iommu_groups/ -name \"*\" -type l | \\\n            xargs -I {} sh -c 'echo \"Group $(basename $(dirname {})): $(basename $(readlink {}))\"' | \\\n            grep \"$bdf\" || echo \"No IOMMU group found\"\n        echo \"\"\n\n        echo \"=== DONOR DUMP DATA ===\"\n        cat \"${output_file}.raw\"\n\n    } &gt; \"$output_file\"\n}\n</code></pre>"},{"location":"manual-donor-dump/#automation-integration","title":"Automation Integration","text":""},{"location":"manual-donor-dump/#cicd-pipeline-integration","title":"CI/CD Pipeline Integration","text":"<pre><code># .github/workflows/donor-dump-validation.yml\nname: Donor Dump Validation\n\non:\n  push:\n    paths:\n      - 'donor_dumps/**'\n      - 'src/donor_dump/**'\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install dependencies\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y jq\n\n      - name: Validate donor dumps\n        run: |\n          for dump in donor_dumps/*.json; do\n            echo \"Validating $dump\"\n            ./scripts/validate_donor_dump.sh \"$dump\"\n          done\n</code></pre>"},{"location":"manual-donor-dump/#security-considerations","title":"Security Considerations","text":""},{"location":"manual-donor-dump/#safe-module-handling","title":"Safe Module Handling","text":"<pre><code># Secure module loading with verification\nsecure_module_load() {\n    local module_path=\"$1\n</code></pre>"},{"location":"manual-donor-dump/#automation-integration_1","title":"Automation Integration","text":""},{"location":"manual-donor-dump/#cicd-pipeline-integration_1","title":"CI/CD Pipeline Integration","text":"<pre><code># .github/workflows/donor-dump-validation.yml\nname: Donor Dump Validation\n\non:\n  push:\n    paths:\n      - 'donor_dumps/**'\n      - 'src/donor_dump/**'\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install dependencies\n        run: |\n          sudo apt-get update\n          sudo apt-get install -y jq\n\n      - name: Validate donor dumps\n        run: |\n          for dump in donor_dumps/*.json; do\n            echo \"Validating $dump\"\n            ./scripts/validate_donor_dump.sh \"$dump\"\n          done\n</code></pre>"},{"location":"manual-donor-dump/#security-considerations_1","title":"Security Considerations","text":""},{"location":"manual-donor-dump/#safe-module-handling_1","title":"Safe Module Handling","text":"<pre><code># Secure module loading with verification\nsecure_module_load() {\n    local module_path=\"$1\"\n    local bdf=\"$2\"\n\n    # Verify module signature (if available)\n    if command -v modinfo &gt;/dev/null 2&gt;&amp;1; then\n        modinfo \"$module_path\" | grep -q \"signature\" &amp;&amp; echo \"\u2713 Module is signed\"\n    fi\n\n    # Check module for suspicious content\n    if command -v strings &gt;/dev/null 2&gt;&amp;1; then\n        if strings \"$module_path\" | grep -qE \"(rm -rf|format|delete)\"; then\n            echo \"\u26a0 WARNING: Module contains potentially dangerous strings\"\n            read -p \"Continue anyway? (y/N): \" -n 1 -r\n            echo\n            [[ ! $REPLY =~ ^[Yy]$ ]] &amp;&amp; return 1\n        fi\n    fi\n\n    # Load with restricted permissions\n    sudo insmod \"$module_path\" bdf=\"$bdf\"\n}\n</code></pre>"},{"location":"manual-donor-dump/#privilege-management","title":"Privilege Management","text":"<pre><code># Check and minimize required privileges\ncheck_privileges() {\n    if [ \"$EUID\" -ne 0 ]; then\n        echo \"This script requires root privileges for:\"\n        echo \"- Loading kernel modules\"\n        echo \"- Accessing PCI configuration space\"\n        echo \"- Reading /proc interfaces\"\n        echo \"\"\n        echo \"Run with: sudo $0\"\n        exit 1\n    fi\n\n    # Drop privileges where possible\n    if command -v sudo &gt;/dev/null 2&gt;&amp;1; then\n        ORIGINAL_USER=\"${SUDO_USER:-$USER}\"\n        echo \"Running as root, will drop privileges where possible\"\n    fi\n}\n</code></pre>"},{"location":"manual-donor-dump/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"manual-donor-dump/#development-workflow","title":"Development Workflow","text":"<ol> <li>Always validate prerequisites before starting</li> <li>Use version control for donor dump files</li> <li>Document device-specific quirks in metadata</li> <li>Test with multiple board types when possible</li> <li>Maintain backup copies of working donor dumps</li> </ol>"},{"location":"manual-donor-dump/#production-deployment","title":"Production Deployment","text":"<ol> <li>Automate validation in CI/CD pipelines</li> <li>Use secure module signing in production</li> <li>Monitor for kernel compatibility issues</li> <li>Implement rollback procedures for failed dumps</li> <li>Log all operations for audit trails</li> </ol>"},{"location":"manual-donor-dump/#performance-optimization_1","title":"Performance Optimization","text":"<ol> <li>Batch process multiple devices when possible</li> <li>Cache build artifacts to avoid rebuilds</li> <li>Use parallel processing for validation</li> <li>Minimize module load/unload cycles</li> <li>Implement smart retry logic for transient failures</li> </ol>"},{"location":"manual-donor-dump/#conclusion","title":"Conclusion","text":"<p>This enhanced manual donor dump generation guide provides:</p> <ul> <li>Comprehensive error handling for robust operation</li> <li>Cross-platform support for Linux and Windows</li> <li>Validation and testing frameworks for quality assurance</li> <li>Performance optimizations for batch processing</li> <li>Security considerations for safe operation</li> <li>Integration examples for automation workflows</li> </ul> <p>The manual process gives you complete control over donor dump generation, making it ideal for: - Debugging automated tool failures - Research and development of new features - Custom integration with existing workflows - Educational purposes to understand the process</p> <p>For most users, the automated <code>pcileech.py</code> command or TUI interface remains the recommended approach, but this manual process provides a powerful alternative when needed.</p>"},{"location":"manual-donor-dump/#quick-reference","title":"Quick Reference","text":""},{"location":"manual-donor-dump/#essential-commands","title":"Essential Commands","text":"<p>Linux: <pre><code># Quick donor dump\ncd PCILeechFWGenerator/src/donor_dump\nmake &amp;&amp; sudo insmod donor_dump.ko bdf=0000:03:00.0\ncat /proc/donor_dump &gt; donor_info.txt\nsudo rmmod donor_dump\n</code></pre></p>"},{"location":"manual-donor-dump/#file-locations","title":"File Locations","text":"<ul> <li>Linux module source: <code>src/donor_dump/</code></li> <li>Validation tools: <code>scripts/validate_donor_dump.sh</code></li> <li>Output directory: <code>donor_dumps/YYYYMMDD_HHMMSS_BDF/</code></li> </ul>"},{"location":"manual-donor-dump/#support-resources","title":"Support Resources","text":"<ul> <li>Main documentation: Home</li> <li>TUI guide: TUI README</li> <li>Development guide: Development</li> <li>Firmware uniqueness: Firmware Uniqueness</li> </ul>"},{"location":"no-fallback-policy/","title":"No Fallback Policy","text":""},{"location":"no-fallback-policy/#overview","title":"Overview","text":"<p>This document explains why the PCILeech firmware generator doesn't allow fallback values for critical device identification parameters like vendor ID and device ID. This prevents creating generic firmware that could be easily detected or compromise security.</p>"},{"location":"no-fallback-policy/#rationale","title":"Rationale","text":""},{"location":"no-fallback-policy/#why-generic-firmware-is-problematic","title":"Why Generic Firmware is Problematic","text":"<p>Using fallback values for device identification parameters (vendor ID, device ID, class code, revision ID) causes several problems:</p> <ol> <li>Non-Unique Firmware: Multiple devices get identical firmware, which defeats the purpose of device-specific cloning</li> <li>Easy Detection: Generic firmware is easily spotted and can be detected by security systems</li> <li>Unrealistic Testing: Generic firmware doesn't match real-world conditions, making research less valuable</li> </ol>"},{"location":"no-fallback-policy/#required-configuration-approach","title":"Required Configuration Approach","text":"<p>The system requires explicit device identification values rather than using fallback defaults:</p> <pre><code>if not device_config.get(\"vendor_id\"):\n    raise ConfigurationError(\"Vendor ID must be provided - no fallback allowed\")\nvendor_id = device_config[\"vendor_id\"]\n</code></pre> <p>This ensures that every generated firmware is specific to the actual target device being cloned.</p>"},{"location":"no-fallback-policy/#how-it-works","title":"How It Works","text":""},{"location":"no-fallback-policy/#1-build-configuration-srcbuildpy","title":"1. Build Configuration (<code>src/build.py</code>)","text":"<p>The <code>extract_device_config</code> method now:</p> <ul> <li>Checks that all required device identification fields are present</li> <li>Looks for zero values (which means invalid configuration)</li> <li>Rejects known generic vendor/device ID combinations</li> <li>Shows clear error messages when something's wrong</li> </ul>"},{"location":"no-fallback-policy/#2-template-files","title":"2. Template Files","text":"<p>All Jinja2 templates now:</p> <ul> <li>Use <code>{%- error %}</code> blocks instead of <code>| default()</code> filters for critical IDs</li> <li>Check required parameters before processing</li> <li>Stop compilation if mandatory fields are missing</li> </ul> <p>Template validation example:</p> <pre><code>{%- if not config_space.device_id %}\n{%- error \"Device ID is required - no fallback values allowed\" %}\n{%- endif %}\n{{ config_space.device_id }}\n</code></pre>"},{"location":"no-fallback-policy/#3-configuration-classes","title":"3. Configuration Classes","text":"<p>Old configuration classes now:</p> <ul> <li>Use <code>Optional[str] = None</code> instead of placeholder defaults</li> <li>Include <code>__post_init__</code> validation methods</li> <li>Raise <code>ValueError</code> if critical fields are not provided</li> </ul>"},{"location":"no-fallback-policy/#files-modified","title":"Files Modified","text":""},{"location":"no-fallback-policy/#core-build-system","title":"Core Build System","text":"<ul> <li><code>src/build.py</code>: Enhanced device config extraction with validation</li> <li><code>src/templating/advanced_sv_generator.py</code>: Removed generic defaults from DeviceConfig</li> </ul>"},{"location":"no-fallback-policy/#template-files","title":"Template Files","text":"<ul> <li><code>src/templates/sv/pcileech_cfgspace.coe.j2</code>: Added error blocks for missing IDs</li> <li><code>src/templates/tcl/pcileech_generate_project.j2</code>: Removed fallback values from TCL generation</li> </ul>"},{"location":"no-fallback-policy/#error-messages","title":"Error Messages","text":"<p>When the system detects missing configuration, users see clear error messages:</p> <pre><code>ConfigurationError: Device configuration is missing from template context. \nThis would create generic firmware that isn't device-specific. \nMake sure device detection and configuration space analysis are working properly.\n</code></pre> <pre><code>ConfigurationError: Vendor ID is zero (0x0000), which means the \ndevice configuration is invalid. This would create generic firmware.\n</code></pre>"},{"location":"no-fallback-policy/#testing","title":"Testing","text":""},{"location":"no-fallback-policy/#working-configuration-test","title":"Working Configuration Test","text":"<pre><code>def test_valid_device_config():\n    config = {\n        \"vendor_id\": 0x8086,  # Intel\n        \"device_id\": 0x1234,  # Specific device\n        \"revision_id\": 0x01,\n        \"class_code\": 0x020000\n    }\n    # Should work\n    result = extract_device_config({\"device_config\": config}, False)\n</code></pre>"},{"location":"no-fallback-policy/#broken-configuration-test","title":"Broken Configuration Test","text":"<pre><code>def test_invalid_device_config():\n    config = {}  # Missing required fields\n    # Should throw an error\n    with pytest.raises(ConfigurationError):\n        extract_device_config({\"device_config\": config}, False)\n</code></pre>"},{"location":"no-fallback-policy/#why-this-helps","title":"Why This Helps","text":"<ol> <li>Security: Makes sure all firmware is device-specific and unique</li> <li>Reliability: Forces proper device detection and configuration</li> <li>Debugging: Clear error messages help find configuration problems</li> <li>Better Research: Prevents unrealistic test scenarios with generic devices</li> </ol>"},{"location":"no-fallback-policy/#updating-existing-code","title":"Updating Existing Code","text":"<p>If you're updating existing code:</p> <ol> <li>Remove Default Parameters: Replace any default vendor/device IDs with proper validation</li> <li>Add Error Handling: Add clear error messages for missing configuration</li> <li>Update Templates: Use <code>{%- error %}</code> blocks instead of <code>| default()</code> filters</li> <li>Test Configuration: Make sure all device identification fields are properly filled in</li> </ol>"},{"location":"no-fallback-policy/#when-fallbacks-are-ok","title":"When Fallbacks Are OK","text":"<p>The only acceptable fallbacks are for:</p> <ul> <li>Subsystem IDs: Can fall back to main vendor/device IDs per PCIe spec</li> <li>Optional Features: Non-critical device features that don't affect uniqueness</li> <li>Vivado Settings: Tool-specific parameters that don't impact device identity</li> </ul> <p>These exceptions are clearly documented and use different validation logic.</p> <p>See Also: Device Cloning Guide, Firmware Uniqueness, Supported Devices</p>"},{"location":"quick-start/","title":"Quick Start Guide","text":"<p>Get up and running with PCILeech Firmware Generator in just a few minutes! This guide assumes you have already completed the installation.</p>"},{"location":"quick-start/#overview","title":"\ud83c\udfaf Overview","text":"<p>This tutorial will walk you through:</p> <ol> <li>Setting up a donor device</li> <li>Generating your first firmware</li> <li>Understanding the output</li> <li>Optional: Flashing to an FPGA</li> </ol>"},{"location":"quick-start/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<p>Before starting, ensure you have:</p> <ul> <li>\u2705 PCILeech Firmware Generator installed</li> <li>\u2705 At least one PCIe device bound to VFIO</li> <li>\u2705 Appropriate permissions (member of <code>vfio</code> group)</li> <li>\u2705 (Optional) Xilinx Vivado installed for synthesis</li> </ul>"},{"location":"quick-start/#step-1-list-available-devices","title":"Step 1: List Available Devices","text":"<p>First, let's see what devices are available for extraction:</p> <pre><code># List all PCIe devices\npcileech-generate --list-devices\n\n# Example output:\n# Available VFIO devices:\n# 0000:01:00.0 - Intel Corporation 82599ES 10-Gigabit SFI/SFP+ Network Connection\n# 0000:02:00.0 - NVIDIA Corporation TU106 [GeForce RTX 2060]\n# 0000:03:00.0 - Samsung Electronics Co Ltd NVMe SSD Controller SM981/PM981/PM983\n</code></pre> <p>No devices shown?</p> <p>If no devices appear, check your VFIO setup and ensure devices are properly bound.</p>"},{"location":"quick-start/#step-2-choose-your-target-board","title":"Step 2: Choose Your Target Board","text":"<p>List supported FPGA boards:</p> <pre><code># Show available board configurations\npcileech-generate --list-boards\n\n# Example output:\n# Available board configurations:\n# - pcileech_100t484_x1    - Artix-7 100T, 484 BGA, PCIe x1\n# - pcileech_35t325_x4     - Artix-7 35T, 325 BGA, PCIe x4  \n# - pcileech_75t484_x1     - Artix-7 75T, 484 BGA, PCIe x1\n</code></pre>"},{"location":"quick-start/#step-3-generate-your-first-firmware","title":"Step 3: Generate Your First Firmware","text":"<p>Now let's generate firmware using a donor device:</p>"},{"location":"quick-start/#basic-generation","title":"Basic Generation","text":"<pre><code># Generate firmware from Intel network card to Artix-7 100T board\npcileech-generate \\\n  --device 0000:01:00.0 \\\n  --board pcileech_100t484_x1 \\\n  --output my_first_firmware\n\n# The generator will:\n# 1. Extract device configuration via VFIO\n# 2. Analyze PCIe capabilities\n# 3. Generate SystemVerilog files\n# 4. Create Vivado project files\n# 5. Save everything to ./my_first_firmware/\n</code></pre>"},{"location":"quick-start/#with-interactive-tui","title":"With Interactive TUI","text":"<p>For a guided experience, use the Terminal User Interface:</p> <pre><code># Launch interactive mode\npcileech-generate --tui\n\n# Follow the prompts to:\n# - Select donor device\n# - Choose target board\n# - Configure options\n# - Generate firmware\n</code></pre>"},{"location":"quick-start/#advanced-options","title":"Advanced Options","text":"<pre><code># Generate with custom options\npcileech-generate \\\n  --device 0000:01:00.0 \\\n  --board pcileech_100t484_x1 \\\n  --output custom_firmware \\\n  --device-id 0x1234 \\\n  --vendor-id 0x8086 \\\n  --unique \\\n  --verbose\n</code></pre>"},{"location":"quick-start/#step-4-understanding-the-output","title":"Step 4: Understanding the Output","text":"<p>After generation, you'll find several important files:</p> <pre><code>my_first_firmware/\n\u251c\u2500\u2500 pcileech_top.sv           # Top-level SystemVerilog module\n\u251c\u2500\u2500 pcileech_tlps128_bar.sv   # BAR controller implementation\n\u251c\u2500\u2500 config_space_init.hex     # Configuration space initialization\n\u251c\u2500\u2500 vivado_project.tcl        # Vivado project script\n\u251c\u2500\u2500 build_instructions.md     # How to build the project\n\u251c\u2500\u2500 device_info.json          # Extracted device information\n\u2514\u2500\u2500 logs/\n    \u251c\u2500\u2500 generation.log        # Detailed generation log\n    \u2514\u2500\u2500 vfio_extraction.log   # VFIO extraction details\n</code></pre>"},{"location":"quick-start/#key-files-explained","title":"Key Files Explained","text":"<ul> <li><code>pcileech_top.sv</code>: The main FPGA design file</li> <li><code>config_space_init.hex</code>: Device configuration data for BRAM initialization</li> <li><code>vivado_project.tcl</code>: Ready-to-use Vivado project script</li> <li><code>device_info.json</code>: Complete device analysis and extracted data</li> </ul>"},{"location":"quick-start/#step-5-verify-generation-success","title":"Step 5: Verify Generation Success","text":"<p>Check that generation completed successfully:</p> <pre><code># Verify output files\nls -la my_first_firmware/\n\n# Check generation log for any issues\ncat my_first_firmware/logs/generation.log | grep -i error\n\n# Validate SystemVerilog syntax (requires Vivado)\npcileech-generate --validate my_first_firmware/\n</code></pre>"},{"location":"quick-start/#step-6-build-fpga-bitstream-optional","title":"Step 6: Build FPGA Bitstream (Optional)","text":"<p>If you have Xilinx Vivado installed, you can synthesize the design:</p> <pre><code># Navigate to output directory\ncd my_first_firmware/\n\n# Run Vivado synthesis\nvivado -mode batch -source vivado_project.tcl\n\n# Or use the generator's build command\npcileech-generate --build .\n\n# The bitstream will be saved as:\n# - project.runs/impl_1/pcileech_top.bit\n</code></pre>"},{"location":"quick-start/#step-7-flash-to-fpga-optional","title":"Step 7: Flash to FPGA (Optional)","text":"<p>If you have a compatible FPGA board and USB-JTAG programmer:</p> <pre><code># Flash the generated firmware directly\npcileech-generate \\\n  --device 0000:01:00.0 \\\n  --board pcileech_100t484_x1 \\\n  --flash\n\n# Or flash an existing bitstream\npcileech-generate --flash-bitstream my_first_firmware/pcileech_top.bit\n</code></pre>"},{"location":"quick-start/#interactive-tui-mode","title":"\ud83c\udf9b\ufe0f Interactive TUI Mode","text":"<p>For beginners, the TUI provides a user-friendly interface:</p> <pre><code># Launch TUI\npcileech-generate --tui\n</code></pre> <p>The TUI will guide you through:</p> <ol> <li>Device Selection: Browse and select from available VFIO devices</li> <li>Board Configuration: Choose your target FPGA board</li> <li>Generation Options: Configure device IDs, uniqueness, etc.</li> <li>Progress Monitoring: Real-time generation progress</li> <li>Result Review: Summary of generated files and next steps</li> </ol>"},{"location":"quick-start/#common-use-cases","title":"\ud83d\udd27 Common Use Cases","text":""},{"location":"quick-start/#network-card-cloning","title":"Network Card Cloning","text":"<pre><code># Clone Intel 10G network card\npcileech-generate \\\n  --device 0000:01:00.0 \\\n  --board pcileech_100t484_x1 \\\n  --unique \\\n  --output intel_10g_clone\n</code></pre>"},{"location":"quick-start/#nvme-storage-controller","title":"NVMe Storage Controller","text":"<pre><code># Clone Samsung NVMe controller\npcileech-generate \\\n  --device 0000:03:00.0 \\\n  --board pcileech_35t325_x4 \\\n  --output nvme_controller\n</code></pre>"},{"location":"quick-start/#custom-device-id","title":"Custom Device ID","text":"<pre><code># Generate with custom IDs\npcileech-generate \\\n  --device 0000:01:00.0 \\\n  --board pcileech_100t484_x1 \\\n  --vendor-id 0x1234 \\\n  --device-id 0x5678 \\\n  --output custom_device\n</code></pre>"},{"location":"quick-start/#troubleshooting-quick-fixes","title":"\ud83d\udc1b Troubleshooting Quick Fixes","text":""},{"location":"quick-start/#no-vfio-devices-found","title":"\"No VFIO devices found\"","text":"<pre><code># Check VFIO module is loaded\nlsmod | grep vfio\n\n# Verify device is bound to VFIO\nls /sys/bus/pci/drivers/vfio-pci/\n</code></pre>"},{"location":"quick-start/#permission-denied-accessing-device","title":"\"Permission denied accessing device\"","text":"<pre><code># Check group membership\ngroups | grep vfio\n\n# Add user to vfio group if needed\nsudo usermod -a -G vfio $USER\n# Log out and back in\n</code></pre>"},{"location":"quick-start/#vivado-not-found","title":"\"Vivado not found\"","text":"<pre><code># Source Vivado environment\nsource /opt/Xilinx/Vivado/*/settings64.sh\n\n# Or add to your shell profile\necho 'source /opt/Xilinx/Vivado/2023.1/settings64.sh' &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"quick-start/#tips-for-success","title":"\u2728 Tips for Success","text":""},{"location":"quick-start/#1-choose-the-right-donor-device","title":"1. Choose the Right Donor Device","text":"<ul> <li>Simple devices (network cards) are easier than complex ones (GPUs)</li> <li>Ensure the device has standard PCIe capabilities</li> <li>Check that VFIO can access all configuration space</li> </ul>"},{"location":"quick-start/#2-match-pcie-lane-count","title":"2. Match PCIe Lane Count","text":"<ul> <li>Use x1 boards for x1 devices</li> <li>Use x4 boards for high-bandwidth devices</li> <li>Consider the target use case for lane count selection</li> </ul>"},{"location":"quick-start/#3-verify-before-building","title":"3. Verify Before Building","text":"<ul> <li>Always check the generation log for warnings</li> <li>Validate device information in <code>device_info.json</code></li> <li>Test with simulation before hardware synthesis</li> </ul>"},{"location":"quick-start/#4-keep-unique-identifiers","title":"4. Keep Unique Identifiers","text":"<ul> <li>Use <code>--unique</code> flag to generate unique device/vendor IDs</li> <li>This prevents conflicts with real hardware</li> <li>Important for security research applications</li> </ul>"},{"location":"quick-start/#next-steps","title":"\ud83c\udf93 Next Steps","text":"<p>Now that you've generated your first firmware:</p> <ol> <li>Device Cloning Guide: Learn advanced device extraction techniques</li> <li>Template Architecture: Understand how the generation works</li> <li>Development Guide: Contribute to the project</li> <li>Troubleshooting: Fix common issues</li> </ol>"},{"location":"quick-start/#additional-resources","title":"\ud83d\udcda Additional Resources","text":"<ul> <li>Configuration Space Documentation: Deep dive into PCIe config space handling</li> <li>Supported Devices: Full list of tested devices</li> <li>TUI Guide: Complete TUI interface documentation</li> </ul> <p>Questions? Check our Troubleshooting Guide or join the Discord Community!</p>"},{"location":"supported-devices/","title":"Supported Devices","text":"<p>PCILeech Firmware Generator supports a wide range of PCIe devices as donors for firmware generation. This page provides detailed information about device compatibility, requirements, and recommendations.</p>"},{"location":"supported-devices/#device-categories","title":"Device Categories","text":""},{"location":"supported-devices/#network-interface-cards-nics","title":"Network Interface Cards (NICs)","text":"<p>Network cards are excellent donors due to their simple PCIe implementation and widespread availability.</p> <p>Recommended Models:</p> <ul> <li>Realtek RTL8111/8168/8411 - Common Gigabit Ethernet controllers</li> <li>Intel 82574L/82579LM - Enterprise-grade NICs with good documentation</li> <li>Broadcom NetXtreme - High-performance network controllers</li> </ul>"},{"location":"supported-devices/#audio-devices","title":"Audio Devices","text":"<p>Sound cards and audio interfaces provide good donor material with well-documented PCIe implementations.</p> <p>Recommended Models:</p> <ul> <li>Creative Sound Blaster series - Professional audio cards</li> <li>ASUS Xonar series - High-quality audio interfaces</li> <li>M-Audio interfaces - Professional audio equipment</li> <li>Generic USB audio controllers - Simple PCIe-to-USB bridges</li> </ul>"},{"location":"supported-devices/#capture-cards","title":"Capture Cards","text":"<p>Video capture devices offer diverse PCIe configurations and are readily available.</p> <p>Recommended Models:</p> <ul> <li>Blackmagic DeckLink series - Professional video capture</li> <li>AVerMedia Live Gamer series - Gaming capture cards</li> <li>Elgato Capture Cards - Streaming-focused devices</li> <li>Hauppauge WinTV series - TV tuner cards</li> </ul>"},{"location":"supported-devices/#other-suitable-devices","title":"Other Suitable Devices","text":"<p>Various other PCIe devices can serve as effective donors.</p> <p>Additional Categories:</p> <ul> <li>SATA/SAS Controllers - Storage interface cards</li> <li>USB 3.0/3.1 Controllers - PCIe-to-USB expansion cards</li> <li>Serial/Parallel Port Cards - Legacy interface adapters</li> <li>GPIO/Digital I/O Cards - Industrial control interfaces</li> </ul>"},{"location":"supported-devices/#device-requirements","title":"Device Requirements","text":""},{"location":"supported-devices/#hardware-requirements","title":"Hardware Requirements","text":"<ul> <li>PCIe Interface - Must be a standard PCIe device (not PCIe-to-PCI bridges)</li> <li>Standard Form Factor - x1, x4, x8, or x16 slots supported</li> <li>Accessible Configuration Space - Device must respond to PCIe configuration reads</li> <li>VFIO Compatible - Must be bindable to VFIO driver</li> </ul>"},{"location":"supported-devices/#software-requirements","title":"Software Requirements","text":"<ul> <li>Linux IOMMU Support - Device must be in a separate IOMMU group</li> <li>VFIO Driver Binding - Must support vfio-pci driver binding</li> <li>Configuration Space Access - Full 4KB configuration space must be readable</li> </ul>"},{"location":"supported-devices/#device-selection-guidelines","title":"Device Selection Guidelines","text":""},{"location":"supported-devices/#ideal-donor-characteristics","title":"Ideal Donor Characteristics","text":"<ol> <li>Simple Implementation - Devices with straightforward PCIe logic</li> <li>Good Documentation - Well-documented devices are easier to analyze</li> <li>Standard Compliance - Devices that follow PCIe specifications closely</li> <li>Stable Operation - Devices that don't require complex initialization</li> </ol>"},{"location":"supported-devices/#devices-to-avoid","title":"Devices to Avoid","text":"<ul> <li>On-board Devices - Integrated audio, network, or storage controllers</li> <li>Critical System Components - Graphics cards, primary storage controllers</li> <li>Complex Multi-function Devices - Devices with multiple PCIe functions</li> <li>Proprietary Implementations - Devices with non-standard PCIe behavior</li> </ul>"},{"location":"supported-devices/#compatibility-testing","title":"Compatibility Testing","text":""},{"location":"supported-devices/#pre-selection-verification","title":"Pre-selection Verification","text":"<p>Before using a device as a donor, verify compatibility:</p> <pre><code># Check device PCIe configuration\nlspci -vvv -s [device_id]\n\n# Verify IOMMU group isolation\n./vfio_check.py [device_id]\n\n# Test VFIO binding\nsudo ./force_vfio_binds.sh [device_id]\n</code></pre>"},{"location":"supported-devices/#configuration-analysis","title":"Configuration Analysis","text":"<p>The generator analyzes several key aspects of donor devices:</p> <ul> <li>Vendor/Device ID - Unique device identification</li> <li>Configuration Space Layout - Register organization and capabilities</li> <li>BAR Configuration - Memory and I/O resource requirements</li> <li>MSI/MSI-X Support - Interrupt handling capabilities</li> <li>Power Management - PCIe power states and control</li> </ul>"},{"location":"supported-devices/#target-fpga-boards","title":"Target FPGA Boards","text":""},{"location":"supported-devices/#supported-pcileech-boards","title":"Supported PCILeech Boards","text":"<p>The generator supports firmware generation for these PCILeech-compatible boards:</p> <ul> <li>pcileech_75t484_x1 - Xilinx Spartan-7 XC7S75T, x1 PCIe</li> <li>pcileech_35t325_x4 - Xilinx Spartan-6 XC6SLX25, x4 PCIe</li> <li>pcileech_100t484_x1 - Xilinx Spartan-7 XC7S100T, x1 PCIe</li> </ul>"},{"location":"supported-devices/#board-specific-considerations","title":"Board-specific Considerations","text":"<p>Each target board has specific resource constraints:</p> <ul> <li>Logic Resources - LUT and flip-flop availability</li> <li>Memory Resources - Block RAM for configuration space shadow</li> <li>I/O Resources - PCIe transceivers and general-purpose I/O</li> <li>Clock Resources - PCIe clock domains and user clocks</li> </ul>"},{"location":"supported-devices/#troubleshooting-device-issues","title":"Troubleshooting Device Issues","text":""},{"location":"supported-devices/#common-problems","title":"Common Problems","text":"<ol> <li>VFIO Binding Failures - Device in use by another driver</li> <li>IOMMU Group Conflicts - Device shares IOMMU group with critical components</li> <li>Configuration Space Errors - Incomplete or corrupted configuration data</li> <li>Power Management Issues - Device doesn't respond after power state changes</li> </ol>"},{"location":"supported-devices/#diagnostic-tools","title":"Diagnostic Tools","text":"<p>Use the included tools to diagnose device issues:</p> <pre><code># Comprehensive device analysis\n./vfio_setup_checker.py --device [device_id] --verbose\n\n# Interactive troubleshooting\n./vfio_setup_checker.py --interactive\n\n# Generate automated fix scripts\n./vfio_setup_checker.py --generate-script\n</code></pre>"},{"location":"supported-devices/#best-practices","title":"Best Practices","text":""},{"location":"supported-devices/#security-considerations","title":"Security Considerations","text":"<ul> <li>Isolated Testing - Use dedicated hardware for donor analysis</li> <li>Firmware Privacy - Keep generated firmware private and secure</li> <li>Clean Environment - Use isolated build environments</li> </ul>"},{"location":"supported-devices/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Device Selection - Choose devices with appropriate complexity</li> <li>Resource Planning - Consider target board resource constraints</li> <li>Testing Methodology - Implement comprehensive testing procedures</li> </ul>"},{"location":"supported-devices/#development-workflow","title":"Development Workflow","text":"<ol> <li>Device Identification - Catalog available donor devices</li> <li>Compatibility Testing - Verify VFIO and IOMMU compatibility</li> <li>Configuration Analysis - Extract and analyze device configuration</li> <li>Firmware Generation - Generate custom firmware for target board</li> <li>Validation Testing - Test generated firmware functionality</li> </ol>"},{"location":"supported-devices/#contributing-device-support","title":"Contributing Device Support","text":""},{"location":"supported-devices/#adding-new-devices","title":"Adding New Devices","text":"<p>To add support for new device types:</p> <ol> <li>Test Compatibility - Verify device works with existing tools</li> <li>Document Configuration - Record device-specific requirements</li> <li>Submit Examples - Provide working configuration examples</li> <li>Update Documentation - Add device to compatibility lists</li> </ol>"},{"location":"supported-devices/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting device compatibility issues:</p> <ol> <li>Provide Device Information - Include lspci output and device details</li> <li>Include Error Messages - Capture complete error logs</li> <li>Describe Environment - Document system configuration</li> <li>Test Isolation - Verify issue isn't system-specific</li> </ol> <p>For more information about device selection and configuration, see the Device Cloning Guide and Development Setup documentation.</p>"},{"location":"template-architecture/","title":"PCIe Capabilities and Template Architecture","text":"<p>This document describes the PCIe capabilities handled by the PCILeech Firmware Generator and provides detailed information about how the SystemVerilog templates are created, filled, and integrated into the final firmware.</p>"},{"location":"template-architecture/#overview","title":"Overview","text":"<p>The PCILeech Firmware Generator creates authentic PCIe device firmware by analyzing real donor hardware and generating comprehensive SystemVerilog implementations. The system handles multiple PCIe capabilities and features through a sophisticated template-based architecture.</p> <p>The generation process involves three main phases:</p> <ol> <li>Device Analysis: Extract configuration space, capabilities, and behavior from donor devices</li> <li>Context Building: Assemble comprehensive template context from all data sources</li> <li>Template Rendering: Generate SystemVerilog modules using Jinja2 templates</li> </ol>"},{"location":"template-architecture/#supported-pcie-capabilities","title":"Supported PCIe Capabilities","text":""},{"location":"template-architecture/#1-configuration-space-shadow-4kb-bram","title":"1. Configuration Space Shadow (4KB BRAM)","text":"<p>The configuration space shadow is the foundation of PCIe device emulation, providing complete 4KB configuration space emulation in FPGA block RAM.</p> <p>Key Features:</p> <ul> <li>Full 4KB Configuration Space: Complete emulation of standard and extended configuration space</li> <li>Dual-Port Access: Simultaneous read/write operations for performance</li> <li>Overlay RAM: Dedicated storage for writable fields (Command/Status registers)</li> <li>Automatic Initialization: Populated from real donor device data or synthetic generation</li> <li>Hardware Integration: Seamless integration with PCIe core configuration interface</li> </ul> <p>Implementation Details:</p> <ul> <li>Main configuration space stored in BRAM (<code>config_space_ram[0:1023]</code>)</li> <li>Overlay RAM for writable fields (<code>overlay_ram[0:OVERLAY_ENTRIES-1]</code>)</li> <li>State machine handles PCIe configuration TLP processing</li> <li>Automatic overlay mapping detects writable registers from PCIe specifications</li> </ul> <pre><code>// Configuration Space Shadow parameters\nparameter CONFIG_SPACE_SIZE = 4096;\nparameter OVERLAY_ENTRIES = 64;\nparameter DUAL_PORT = 1;\n</code></pre>"},{"location":"template-architecture/#2-msi-x-message-signaled-interrupts-extended","title":"2. MSI-X (Message Signaled Interrupts Extended)","text":"<p>MSI-X provides scalable interrupt handling with up to 2048 interrupt vectors, essential for modern PCIe devices.</p> <p>MSI-X Table Structure:</p> <ul> <li>Message Address Lower (32-bit): Target memory address for interrupt message</li> <li>Message Address Upper (32-bit): Upper 32 bits for 64-bit addressing</li> <li>Message Data (32-bit): Interrupt payload data</li> <li>Vector Control (32-bit): Mask bit and reserved fields</li> </ul> <p>Features Implemented:</p> <ul> <li>Parameterized Table Size: 1-2048 vectors based on donor device</li> <li>BRAM-based Table Storage: Efficient memory usage with block RAM attributes</li> <li>Pending Bit Array (PBA): Tracks pending interrupts for masked vectors</li> <li>Interrupt Delivery Logic: Validates vectors and delivers interrupts</li> <li>Byte-Enable Support: Granular write access to table entries</li> </ul> <p>Template Integration:</p> <pre><code>// MSI-X Table parameters derived from donor device\nparameter NUM_MSIX = {{ NUM_MSIX }};\nparameter MSIX_TABLE_BIR = {{ MSIX_TABLE_BIR }};\nparameter MSIX_TABLE_OFFSET = {{ MSIX_TABLE_OFFSET }};\nparameter MSIX_PBA_BIR = {{ MSIX_PBA_BIR }};\nparameter MSIX_PBA_OFFSET = {{ MSIX_PBA_OFFSET }};\n</code></pre>"},{"location":"template-architecture/#3-power-management-capability","title":"3. Power Management Capability","text":"<p>Power management enables PCIe devices to transition between different power states (D0, D1, D2, D3hot, D3cold).</p> <p>Power States Supported:</p> <ul> <li>D0: Fully operational state</li> <li>D3hot: Low power state with auxiliary power</li> <li>D3cold: No power state (requires external power cycling)</li> </ul> <p>Implementation Features:</p> <ul> <li>PMCSR Register: Power Management Control and Status Register</li> <li>PME Support: Power Management Event signaling</li> <li>State Transitions: Automatic timeout-based transitions</li> <li>Minimal Resource Usage: &lt;40 LUT, &lt;50 FF implementation</li> </ul>"},{"location":"template-architecture/#4-pcie-express-capability","title":"4. PCIe Express Capability","text":"<p>The PCIe Express capability provides device-specific PCIe functionality and advanced features.</p> <p>Key Registers:</p> <ul> <li>PCIe Capabilities Register: Device type and supported features</li> <li>Device Control/Status: Device-specific control and status bits</li> <li>Link Control/Status: Link training and status information</li> <li>Device Capabilities 2: Advanced device capabilities</li> </ul> <p>Template Variables:</p> <ul> <li>Device-specific capability values extracted from donor device</li> <li>Link width and speed configuration</li> <li>ASPM (Active State Power Management) settings</li> <li>Error reporting capabilities</li> </ul>"},{"location":"template-architecture/#5-base-address-registers-bars","title":"5. Base Address Registers (BARs)","text":"<p>BAR implementation provides memory-mapped I/O regions for device communication.</p> <p>BAR Types Supported:</p> <ul> <li>Memory BARs: 32-bit and 64-bit memory regions</li> <li>I/O BARs: I/O port regions (legacy support)</li> <li>Prefetchable Memory: Optimized for bulk data transfer</li> </ul> <p>Features:</p> <ul> <li>Parameterized Sizes: 4KB to 4GB regions</li> <li>Address Decoding: Automatic address range validation</li> <li>Regional Memory Access: Subdivided into functional regions</li> <li>Burst Support: Optimized for high-throughput operations</li> </ul>"},{"location":"template-architecture/#template-architecture","title":"Template Architecture","text":"<p>The PCILeech template system uses a sophisticated multi-phase approach to generate authentic PCIe device firmware.</p>"},{"location":"template-architecture/#1-data-collection-phase","title":"1. Data Collection Phase","text":""},{"location":"template-architecture/#device-binding-and-analysis","title":"Device Binding and Analysis","text":"<p>The generation process begins with comprehensive device analysis:</p> <ol> <li>VFIO Driver Binding: Bind target device to VFIO driver for direct access</li> <li>Configuration Space Reading: Extract complete 4KB configuration space</li> <li>Capability Walking: Parse and identify all PCIe capabilities</li> <li>BAR Size Detection: Determine BAR sizes through write-back testing</li> <li>MSI-X Table Analysis: Extract interrupt table configuration if present</li> </ol>"},{"location":"template-architecture/#manufacturing-variance-application","title":"Manufacturing Variance Application","text":"<p>To make generated firmware more realistic, the system applies manufacturing variance:</p> <pre><code># Manufacturing variance parameters\nclass VarianceParameters:\n    clock_jitter_percent_min: float = 2.0\n    clock_jitter_percent_max: float = 5.0\n    register_timing_jitter_ns_min: float = 10.0\n    register_timing_jitter_ns_max: float = 50.0\n    process_variation_percent_min: float = 5.0\n    process_variation_percent_max: float = 15.0\n</code></pre>"},{"location":"template-architecture/#2-context-building-phase","title":"2. Context Building Phase","text":""},{"location":"template-architecture/#pcileechcontextbuilder-integration","title":"PCILeechContextBuilder Integration","text":"<p>The <code>PCILeechContextBuilder</code> class assembles comprehensive template context from all data sources:</p> <pre><code>class PCILeechContextBuilder:\n    def build_context(\n        self,\n        behavior_profile: Optional[BehaviorProfile],\n        config_space_data: Dict[str, Any],\n        msix_data: Optional[Dict[str, Any]],\n        interrupt_strategy: str = \"intx\",\n        interrupt_vectors: int = 1,\n    ) -&gt; Dict[str, Any]:\n</code></pre>"},{"location":"template-architecture/#context-assembly-process","title":"Context Assembly Process","text":"<ol> <li>Device Identifiers: Extract vendor/device IDs, class codes, revision</li> <li>Configuration Space Context: Process 4KB configuration space data</li> <li>MSI-X Context: Parse MSI-X table and PBA information</li> <li>BAR Configuration: Analyze BAR sizes, types, and memory regions</li> <li>Timing Configuration: Apply manufacturing variance and timing parameters</li> <li>Overlay Mapping: Generate writable register overlay mappings</li> </ol>"},{"location":"template-architecture/#3-template-processing-pipeline","title":"3. Template Processing Pipeline","text":""},{"location":"template-architecture/#phase-1-analysis-and-extraction","title":"Phase 1: Analysis and Extraction","text":"<ol> <li>Device Binding: Bind donor device to VFIO driver</li> <li>Configuration Space Reading: Extract 4KB configuration space</li> <li>Capability Walking: Parse and analyze PCIe capabilities</li> <li>BAR Analysis: Determine BAR sizes and types</li> <li>MSI-X Table Reading: Extract MSI-X table data if present</li> </ol>"},{"location":"template-architecture/#phase-2-context-generation","title":"Phase 2: Context Generation","text":"<ol> <li>Device Profile Creation: Generate device configuration structure</li> <li>Capability Mapping: Map capabilities to template parameters</li> <li>Overlay Mapping: Determine writable register overlays</li> <li>Manufacturing Variance: Apply deterministic timing variations</li> <li>Template Context Assembly: Combine all data sources</li> </ol>"},{"location":"template-architecture/#phase-3-template-rendering","title":"Phase 3: Template Rendering","text":"<ol> <li>Template Selection: Choose appropriate templates based on device type</li> <li>Context Injection: Apply template context to Jinja2 templates</li> <li>Code Generation: Generate SystemVerilog modules</li> <li>File Integration: Create project files and build scripts</li> </ol>"},{"location":"template-architecture/#4-overlay-mapping-system","title":"4. Overlay Mapping System","text":"<p>The overlay mapping system automatically detects writable registers in PCIe configuration space:</p> <pre><code>class OverlayMapper:\n    def detect_overlay_registers(\n        self, config_space: Dict[int, int], capabilities: Dict[str, int]\n    ) -&gt; List[Tuple[int, int]]:\n        \"\"\"\n        Detect registers that need overlay RAM for writable fields.\n        Returns list of (offset, mask) tuples for overlay entries.\n        \"\"\"\n</code></pre> <p>Overlay Detection Process:</p> <ol> <li>Standard Register Analysis: Check Command/Status, BAR, and capability registers</li> <li>Capability-Specific Overlays: MSI-X, Power Management, PCIe Express registers</li> <li>Mask Generation: Create bit-level masks for writable fields</li> <li>Validation: Ensure overlay mappings are consistent with PCIe specifications</li> </ol>"},{"location":"template-architecture/#systemverilog-module-hierarchy","title":"SystemVerilog Module Hierarchy","text":""},{"location":"template-architecture/#1-top-level-module","title":"1. Top-Level Module","text":"<ul> <li>pcileech_top: Main wrapper module</li> <li>Responsibilities: Clock/reset distribution, PCIe interface, module instantiation</li> <li>Template: <code>top_level_wrapper.sv.j2</code></li> </ul>"},{"location":"template-architecture/#2-core-controller","title":"2. Core Controller","text":"<ul> <li>pcileech_tlps128_bar_controller: Main device controller</li> <li>Responsibilities: TLP processing, BAR management, capability coordination</li> <li>Template: <code>pcileech_tlps128_bar_controller.sv.j2</code></li> </ul>"},{"location":"template-architecture/#3-configuration-space-shadow","title":"3. Configuration Space Shadow","text":"<ul> <li>pcileech_tlps128_cfgspace_shadow: Configuration space implementation</li> <li>Responsibilities: Config space access, overlay management, capability registers</li> <li>Template: <code>cfg_shadow.sv.j2</code></li> </ul>"},{"location":"template-architecture/#4-msi-x-subsystem","title":"4. MSI-X Subsystem","text":"<ul> <li>msix_table: MSI-X table and PBA implementation</li> <li>Responsibilities: Interrupt table management, vector delivery, masking</li> <li>Template: <code>msix_table.sv.j2</code></li> </ul>"},{"location":"template-architecture/#5-power-management","title":"5. Power Management","text":"<ul> <li>pmcsr_stub: Power management implementation</li> <li>Responsibilities: D-state transitions, PME handling, power control</li> <li>Template: <code>pmcsr_stub.sv.j2</code></li> </ul>"},{"location":"template-architecture/#6-memory-regions","title":"6. Memory Regions","text":"<ul> <li>region_device_ctrl: Device control region</li> <li>region_data_buffer: Data buffer region</li> <li>region_custom_pio: Custom PIO region</li> <li>Templates: Various region-specific templates</li> </ul>"},{"location":"template-architecture/#configuration-space-structure","title":"Configuration Space Structure","text":""},{"location":"template-architecture/#standard-configuration-space-0x00-0xff","title":"Standard Configuration Space (0x00-0xFF)","text":"<ul> <li>0x00-0x03: Vendor ID / Device ID</li> <li>0x04-0x07: Command / Status</li> <li>0x08-0x0B: Class Code / Revision ID</li> <li>0x0C-0x0F: Cache Line Size / Latency Timer / Header Type / BIST</li> <li>0x10-0x27: Base Address Registers (BARs 0-5)</li> <li>0x28-0x2B: Cardbus CIS Pointer</li> <li>0x2C-0x2F: Subsystem Vendor ID / Subsystem ID</li> <li>0x30-0x33: Expansion ROM Base Address</li> <li>0x34-0x3B: Capabilities Pointer / Reserved</li> <li>0x3C-0x3F: Interrupt Line / Pin / Min_Gnt / Max_Lat</li> </ul>"},{"location":"template-architecture/#capability-structures-0x40-0xff","title":"Capability Structures (0x40-0xFF)","text":"<ul> <li>0x40-0x47: Power Management Capability</li> <li>0x48-0x4F: MSI Capability (if not using MSI-X)</li> <li>0x50-0x5B: MSI-X Capability (if supported)</li> <li>0x60-0x9F: PCIe Express Capability</li> </ul>"},{"location":"template-architecture/#extended-configuration-space-0x100-0xfff","title":"Extended Configuration Space (0x100-0xFFF)","text":"<ul> <li>0x100-0x2FF: MSI-X Table (if supported)</li> <li>0x300-0x3FF: MSI-X PBA (if supported)</li> <li>0x400-0xFFF: Extended capabilities and vendor-specific regions</li> </ul>"},{"location":"template-architecture/#memory-organization","title":"Memory Organization","text":""},{"location":"template-architecture/#bar-memory-layout","title":"BAR Memory Layout","text":"<pre><code>BAR0 Memory Map (example):\n0x0000-0x00FF: Device Control Region\n0x0100-0x01FF: Status Registers\n0x0200-0x03FF: Data Buffer\n0x0400-0x0FFF: Custom PIO Region\n0x1000-0x1FFF: MSI-X Table (if applicable)\n0x2000-0x2FFF: MSI-X PBA (if applicable)\n</code></pre>"},{"location":"template-architecture/#bram-allocation","title":"BRAM Allocation","text":"<ul> <li>Configuration Space: 4KB block RAM for complete config space</li> <li>Overlay RAM: Variable size based on writable register count</li> <li>MSI-X Table: Sized based on interrupt vector count</li> <li>Data Buffers: Parameterized based on device requirements</li> </ul>"},{"location":"template-architecture/#build-integration","title":"Build Integration","text":""},{"location":"template-architecture/#1-project-file-generation","title":"1. Project File Generation","text":"<p>The template system generates complete Vivado project files:</p> <ul> <li>TCL Scripts: Project creation and configuration</li> <li>Constraint Files: Timing and placement constraints</li> <li>Memory Initialization: Configuration space and MSI-X table data</li> </ul>"},{"location":"template-architecture/#2-synthesis-optimization","title":"2. Synthesis Optimization","text":"<p>Templates include synthesis-specific optimizations:</p> <ul> <li>RAM Style Attributes: Force block RAM inference</li> <li>Timing Constraints: Critical path optimization</li> <li>Resource Sharing: Efficient multiplexer generation</li> </ul>"},{"location":"template-architecture/#3-simulation-support","title":"3. Simulation Support","text":"<p>Generated code includes simulation features:</p> <ul> <li>Testbench Integration: Automatic test pattern generation</li> <li>Debug Outputs: Comprehensive status and debug signals</li> <li>Assertion Checking: SystemVerilog assertions for verification</li> </ul>"},{"location":"template-architecture/#manufacturing-variance","title":"Manufacturing Variance","text":""},{"location":"template-architecture/#deterministic-variance-application","title":"Deterministic Variance Application","text":"<p>The system applies realistic manufacturing variance to make generated firmware less detectable:</p> <pre><code>class ManufacturingVarianceSimulator:\n    def apply_timing_variance(\n        self, base_timing: float, variance_percent: float\n    ) -&gt; float:\n        \"\"\"Apply deterministic timing variance based on device characteristics.\"\"\"\n</code></pre>"},{"location":"template-architecture/#variance-categories","title":"Variance Categories","text":"<ol> <li>Clock Jitter: 2-5% variation in clock timing</li> <li>Register Timing: 10-50ns jitter in register access</li> <li>Power Noise: 1-3% supply voltage variation effects</li> <li>Process Variation: 5-15% parameter variation</li> <li>Temperature Drift: 10-100 ppm/\u00b0C timing drift</li> </ol>"},{"location":"template-architecture/#testing-and-validation","title":"Testing and Validation","text":""},{"location":"template-architecture/#template-validation","title":"Template Validation","text":"<ol> <li>Syntax Checking: Validate generated SystemVerilog syntax</li> <li>Simulation Testing: Verify functionality with test patterns</li> <li>Timing Analysis: Ensure timing constraints are met</li> <li>Resource Utilization: Verify efficient FPGA resource usage</li> </ol>"},{"location":"template-architecture/#capability-testing","title":"Capability Testing","text":"<ol> <li>Configuration Space Access: Test all configuration registers</li> <li>MSI-X Functionality: Verify interrupt table operation</li> <li>Power Management: Test D-state transitions</li> <li>BAR Access: Validate memory region access patterns</li> </ol>"},{"location":"template-architecture/#future-extensions","title":"Future Extensions","text":""},{"location":"template-architecture/#planned-capabilities","title":"Planned Capabilities","text":"<ul> <li>SR-IOV: Single Root I/O Virtualization support</li> <li>AER: Advanced Error Reporting capability</li> <li>ATS: Address Translation Services</li> <li>ACS: Access Control Services</li> </ul>"},{"location":"template-architecture/#template-system-enhancements","title":"Template System Enhancements","text":"<ul> <li>Multi-Function Support: Multiple PCIe functions per device</li> <li>Dynamic Reconfiguration: Runtime capability modification</li> <li>Enhanced Debugging: Improved debug and trace capabilities</li> <li>Performance Optimization: Advanced timing and resource optimization</li> </ul> <p>For more detailed information about specific capabilities, see the individual documentation pages for Configuration Space Shadow, MSI-X Implementation, and Device Cloning Process.</p>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide covers common issues and their solutions when using PCILeech Firmware Generator.</p>"},{"location":"troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>VFIO Setup Issues</li> <li>Installation Issues</li> <li>BAR Detection Issues</li> <li>VFIO Binding Problems</li> <li>Build Failures</li> <li>Device-Specific Issues</li> <li>SystemVerilog Generation Errors</li> <li>Getting Help</li> </ul>"},{"location":"troubleshooting/#vfio-setup-issues","title":"VFIO Setup Issues","text":"<p>Warning: Avoid using on-board devices (audio, graphics cards) for donor info. The VFIO process can lock the bus during extraction and cause system reboots.</p> <p>The most common issues involve VFIO (Virtual Function I/O) configuration. Use the built-in diagnostic tool:</p> <pre><code># Check VFIO setup and device compatibility\nsudo python3 pcileech.py check\n\n# Check a specific device\nsudo python3 pcileech.py check --device 0000:03:00.0\n\n# Interactive mode with guided fixes\nsudo python3 pcileech.py check --interactive\n\n# Attempt automatic fixes\nsudo python3 pcileech.py check --fix\n</code></pre>"},{"location":"troubleshooting/#common-vfio-problems","title":"Common VFIO Problems","text":"<p>1. IOMMU not enabled in BIOS/UEFI <pre><code># Enable VT-d (Intel) or AMD-Vi (AMD) in BIOS settings\n# Then add to /etc/default/grub GRUB_CMDLINE_LINUX:\n# For Intel: intel_iommu=on\n# For AMD: amd_iommu=on\nsudo update-grub &amp;&amp; sudo reboot\n</code></pre></p> <p>2. VFIO modules not loaded <pre><code>sudo modprobe vfio vfio_pci vfio_iommu_type1\n</code></pre></p> <p>3. Device not in IOMMU group <pre><code># Check IOMMU groups\nfind /sys/kernel/iommu_groups/ -name '*' -type l | grep YOUR_DEVICE_BDF\n</code></pre></p> <p>4. Permission issues <pre><code># Add user to required groups\nsudo usermod -a -G vfio $USER\nsudo usermod -a -G dialout $USER  # For USB-JTAG access\n</code></pre></p> <p>5. ACS (Access Control Services) errors <pre><code># Devices sharing IOMMU groups - common on Ubuntu\n# See diagnostic tool output for solutions\n</code></pre></p>"},{"location":"troubleshooting/#installation-issues","title":"Installation Issues","text":"<pre><code># If pip installation fails\npip install --upgrade pip setuptools wheel\npip install pcileechfwgenerator[tui]\n\n# For TUI dependencies\npip install textual rich psutil watchdog\n\n# Container issues\npodman --version\npodman info | grep rootless\n</code></pre>"},{"location":"troubleshooting/#bar-detection-issues","title":"BAR Detection Issues","text":"<p>Problem: BARs not detected or incorrectly sized</p> <p>Solutions: 1. Ensure device is properly bound to VFIO 2. Check that the device is not in use by another driver 3. Verify IOMMU group isolation 4. Use manual BAR specification if auto-detection fails</p> <pre><code># Manual BAR specification\nsudo python3 pcileech.py build --bdf 0000:03:00.0 \\\n  --bar0-size 0x1000 --bar1-size 0x100000\n</code></pre>"},{"location":"troubleshooting/#vfio-binding-problems","title":"VFIO Binding Problems","text":"<p>Problem: Cannot bind device to VFIO driver</p> <p>Solutions:</p> <ol> <li> <p>Check if device is in use: <pre><code>lspci -k -s 0000:03:00.0\n# Should show vfio-pci as driver\n</code></pre></p> </li> <li> <p>Unbind from current driver: <pre><code>echo \"0000:03:00.0\" | sudo tee /sys/bus/pci/devices/0000:03:00.0/driver/unbind\n</code></pre></p> </li> <li> <p>Bind to VFIO: <pre><code>echo \"1234 5678\" | sudo tee /sys/bus/pci/drivers/vfio-pci/new_id\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#build-failures","title":"Build Failures","text":"<p>Problem: SystemVerilog generation fails</p> <p>Common causes and solutions:</p> <ol> <li>Template errors: Check log output for specific template issues</li> <li>Missing device data: Ensure VFIO extraction completed successfully</li> <li>BAR configuration conflicts: Verify BAR sizes and types</li> <li>MSI-X table issues: Check MSI-X capability detection</li> </ol> <pre><code># Enable verbose logging\nsudo python3 pcileech.py build --bdf 0000:03:00.0 --verbose\n</code></pre>"},{"location":"troubleshooting/#device-specific-issues","title":"Device-Specific Issues","text":""},{"location":"troubleshooting/#network-cards","title":"Network Cards","text":"<ul> <li>Intel NICs: May require special VFIO handling</li> <li>Realtek cards: Often work well as donors</li> <li>Broadcom devices: Check for firmware dependencies</li> </ul>"},{"location":"troubleshooting/#usb-controllers","title":"USB Controllers","text":"<ul> <li>XHCI controllers: Complex capability structures</li> <li>Legacy USB: May have simpler BAR layouts</li> <li>USB 3.0 hubs: Good donor candidates</li> </ul>"},{"location":"troubleshooting/#audio-cards","title":"Audio Cards","text":"<ul> <li>Sound Blaster: Usually good donors</li> <li>USB audio: May have complex descriptors</li> <li>Onboard audio: Avoid - can cause system issues</li> </ul>"},{"location":"troubleshooting/#systemverilog-generation-errors","title":"SystemVerilog Generation Errors","text":"<p>Problem: Generated SystemVerilog has syntax errors</p> <p>Solutions:</p> <ol> <li> <p>Check template integrity: <pre><code># Verify template files are not corrupted\nls -la templates/\n</code></pre></p> </li> <li> <p>Validate device data: <pre><code># Use debug mode to inspect extracted data\nsudo python3 pcileech.py build --debug --dry-run\n</code></pre></p> </li> <li> <p>Manual template fixes: <pre><code># Edit templates if necessary\nvim templates/pcileech_tlps128_bar_controller.sv.j2\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still experiencing issues:</p> <ol> <li>Check the documentation: Browse all available guides</li> <li>Use diagnostic tools: Run built-in checks and diagnostics</li> <li>Enable debug logging: Use <code>--debug</code> and <code>--verbose</code> flags</li> <li>Search existing issues: Check GitHub issues for similar problems</li> <li>Create a detailed issue: Include logs, system info, and device details</li> </ol>"},{"location":"troubleshooting/#creating-effective-bug-reports","title":"Creating Effective Bug Reports","text":"<p>Include the following information:</p> <ul> <li>Operating system and kernel version</li> <li>Device PCI ID and BDF</li> <li>Complete error logs with <code>--debug</code> enabled</li> <li>Output of diagnostic checks</li> <li>Steps to reproduce the issue</li> </ul>"},{"location":"troubleshooting/#community-support","title":"Community Support","text":"<ul> <li>GitHub Issues: For bug reports and feature requests</li> <li>GitHub Discussions: For questions and community help</li> <li>Discord: Real-time community support</li> </ul> <p>Remember: This tool requires real hardware and proper VFIO setup. Most issues are related to VFIO configuration rather than the tool itself.</p>"},{"location":"tui-readme/","title":"\ud83d\udda5\ufe0f PCILeech Firmware Generator TUI","text":"<p>A modern Text User Interface (TUI) for the PCILeech firmware generation workflow, built with the Textual framework.</p>"},{"location":"tui-readme/#table-of-contents","title":"\ud83d\udcd1 Table of Contents","text":"<ul> <li>\ud83d\udd0d Overview</li> <li>\ud83d\ude80 Installation</li> <li>Prerequisites</li> <li>Install TUI Dependencies</li> <li>\ud83c\udfae Usage</li> <li>Launch TUI Mode</li> <li>TUI Interface Overview</li> <li>\u2728 Features</li> <li>Device Management</li> <li>Configuration Management</li> <li>Build Monitoring</li> <li>System Integration</li> <li>\u2699\ufe0f Configuration Profiles</li> <li>Profile Locations</li> <li>Default Profiles</li> <li>Creating Custom Profiles</li> <li>\u2328\ufe0f Keyboard Shortcuts</li> <li>\ud83d\udd27 Error Handling</li> <li>Common Errors and Solutions</li> <li>\ud83d\ude80 Advanced Features</li> <li>Behavior Profiling</li> <li>System Status Monitoring</li> <li>Build Process Integration</li> <li>Configuration Validation</li> <li>\ud83d\udc1b Troubleshooting</li> <li>TUI Won't Start</li> <li>Device Detection Issues</li> <li>Build Failures</li> <li>\ud83d\udee0\ufe0f Development</li> <li>Architecture</li> <li>Key Components</li> <li>Extending the TUI</li> <li>\ud83e\udd1d Contributing</li> <li>\ud83d\udcc4 License</li> <li>\u26a0\ufe0f Disclaimer</li> </ul>"},{"location":"tui-readme/#overview","title":"\ud83d\udd0d Overview","text":"<p>The TUI provides an interactive, user-friendly interface that addresses the key pain points of the command-line workflow:</p> <ul> <li>Enhanced Device Discovery: Visual PCIe device browser with detailed information</li> <li>Guided Configuration: Intuitive configuration wizard with validation</li> <li>Real-time Build Monitoring: Live progress tracking with resource usage</li> <li>Error Guidance: Intelligent error analysis with suggested fixes</li> <li>Profile Management: Save and load configuration profiles</li> </ul>"},{"location":"tui-readme/#installation","title":"\ud83d\ude80 Installation","text":""},{"location":"tui-readme/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or higher</li> <li>Root/sudo access (required for device binding)</li> <li>Podman container runtime</li> <li>PCILeech firmware generation environment</li> </ul>"},{"location":"tui-readme/#install-tui-dependencies","title":"Install TUI Dependencies","text":"<pre><code># Install TUI-specific dependencies\npip install -r requirements-tui.txt\n\n# Or install individual packages\npip install textual rich psutil watchdog pydantic\n</code></pre>"},{"location":"tui-readme/#usage","title":"\ud83c\udfae Usage","text":""},{"location":"tui-readme/#launch-tui-mode","title":"Launch TUI Mode","text":"<p>There are several ways to launch the TUI:</p> <pre><code># Method 1: Using the unified entrypoint (recommended)\nsudo python3 pcileech.py tui\n\n# Method 2: Direct execution \nsudo python3 -m src.tui.main\n\n# Method 3: Using the sudo wrapper (if installed)\n./install-sudo-wrapper.sh  # Install the wrapper first (one-time setup)\npcileech-tui-sudo\n</code></pre> <p>Note: UI operations require root privileges. The sudo wrapper script preserves the Python environment when running with sudo, preventing module import errors.</p>"},{"location":"tui-readme/#tui-interface-overview","title":"TUI Interface Overview","text":"<p>The TUI is organized into several panels:</p>"},{"location":"tui-readme/#1-device-selection-panel-top-left","title":"1. Device Selection Panel (Top Left)","text":"<ul> <li>Lists all detected PCIe devices</li> <li>Shows device status, BDF address, name, driver, and IOMMU group</li> <li>Provides device suitability indicators</li> <li>Refresh and details buttons</li> </ul>"},{"location":"tui-readme/#2-configuration-panel-top-right","title":"2. Configuration Panel (Top Right)","text":"<ul> <li>Displays current build configuration</li> <li>Shows board type, device type, and enabled features</li> <li>Configure, load profile, and save profile buttons</li> </ul>"},{"location":"tui-readme/#3-build-progress-panel-middle","title":"3. Build Progress Panel (Middle)","text":"<ul> <li>Real-time build progress with stage tracking</li> <li>Resource usage monitoring (CPU, memory, disk)</li> <li>Build control buttons (start, pause, stop)</li> <li>Log viewing capability</li> </ul>"},{"location":"tui-readme/#4-system-status-panel-bottom-left","title":"4. System Status Panel (Bottom Left)","text":"<ul> <li>Podman availability and status</li> <li>Vivado detection and version</li> <li>USB device count</li> <li>Disk space information</li> <li>Root access status</li> </ul>"},{"location":"tui-readme/#5-quick-actions-panel-bottom-right","title":"5. Quick Actions Panel (Bottom Right)","text":"<ul> <li>Device scanning</li> <li>Output directory access</li> <li>Build report viewing</li> <li>Advanced settings</li> <li>Documentation links</li> </ul>"},{"location":"tui-readme/#features","title":"\u2728 Features","text":""},{"location":"tui-readme/#device-management","title":"Device Management","text":"<ul> <li>Auto-discovery: Automatically scans and lists PCIe devices</li> <li>Enhanced Information: Shows vendor names, driver status, IOMMU groups</li> <li>Suitability Assessment: Rates devices for firmware generation compatibility</li> <li>Driver Status: Indicates if devices are bound to drivers</li> </ul>"},{"location":"tui-readme/#configuration-management","title":"Configuration Management","text":"<ul> <li>Profile System: Save and load configuration profiles</li> <li>Default Profiles: Pre-configured profiles for common scenarios:</li> <li>Network Device Standard</li> <li>Storage Device Optimized</li> <li>Quick Development</li> <li>Full Featured</li> <li>Validation: Real-time configuration validation with error messages</li> </ul>"},{"location":"tui-readme/#build-monitoring","title":"Build Monitoring","text":"<ul> <li>Stage Tracking: Visual progress through 6 build stages:</li> <li>Environment Validation</li> <li>Device Analysis</li> <li>Register Extraction</li> <li>SystemVerilog Generation</li> <li>Vivado Synthesis</li> <li>Bitstream Generation</li> <li>Resource Monitoring: Real-time CPU, memory, and disk usage</li> <li>Error Detection: Automatic error detection with guided recovery</li> </ul>"},{"location":"tui-readme/#system-integration","title":"System Integration","text":"<ul> <li>Backward Compatibility: Maintains all existing CLI functionality</li> <li>Container Integration: Seamless integration with Podman containers</li> <li>Log Management: Integrated log viewing and analysis</li> <li>USB Device Support: Automatic USB device detection for flashing</li> </ul>"},{"location":"tui-readme/#configuration-profiles","title":"\u2699\ufe0f Configuration Profiles","text":""},{"location":"tui-readme/#profile-locations","title":"Profile Locations","text":"<p>Profiles are stored in <code>~/.pcileech/profiles/</code> as JSON files.</p>"},{"location":"tui-readme/#default-profiles","title":"Default Profiles","text":""},{"location":"tui-readme/#network-device-standard","title":"Network Device Standard","text":"<pre><code>{\n  \"name\": \"Network Device Standard\",\n  \"board_type\": \"pcileech_35t325_x1\",\n  \"advanced_sv\": true,\n  \"enable_variance\": true,\n  \"behavior_profiling\": true,\n  \"profile_duration\": 30.0,\n  \"donor_dump\": true\n}\n</code></pre>"},{"location":"tui-readme/#quick-development","title":"Quick Development","text":"<pre><code>{\n  \"name\": \"Quick Development\",\n  \"board_type\": \"pcileech_35t325_x1\",\n  \"advanced_sv\": false,\n  \"enable_variance\": false,\n  \"flash_after_build\": true,\n  \"donor_dump\": true\n}\n</code></pre>"},{"location":"tui-readme/#local-build","title":"Local Build","text":"<pre><code>{\n  \"name\": \"Local Build\",\n  \"board_type\": \"pcileech_35t325_x1\",\n  \"advanced_sv\": true,\n  \"enable_variance\": true,\n  \"donor_dump\": false,\n  \"local_build\": true,\n  \"donor_info_file\": \"~/.pcileech/donor_info.json\"\n}\n</code></pre>"},{"location":"tui-readme/#creating-custom-profiles","title":"Creating Custom Profiles","text":"<ol> <li>Configure settings in the TUI</li> <li>Click \"Save Profile\"</li> <li>Enter a profile name</li> <li>Profile is saved to <code>~/.pcileech/profiles/</code></li> </ol>"},{"location":"tui-readme/#keyboard-shortcuts","title":"\u2328\ufe0f Keyboard Shortcuts","text":"<ul> <li><code>Ctrl+C</code>: Exit application</li> <li><code>Tab</code>: Navigate between panels</li> <li><code>Enter</code>: Activate selected button/item</li> <li><code>Space</code>: Toggle checkboxes</li> <li><code>\u2191/\u2193</code>: Navigate lists and tables</li> <li><code>F1</code>: Help (if implemented)</li> </ul>"},{"location":"tui-readme/#error-handling","title":"\ud83d\udd27 Error Handling","text":"<p>The TUI provides intelligent error analysis and guidance:</p>"},{"location":"tui-readme/#common-errors-and-solutions","title":"Common Errors and Solutions","text":""},{"location":"tui-readme/#vfio-binding-failed","title":"VFIO Binding Failed","text":"<ul> <li>Cause: IOMMU not enabled or vfio-pci module not loaded</li> <li>Solutions:</li> <li>Enable IOMMU in BIOS</li> <li>Load vfio-pci module: <code>modprobe vfio-pci</code></li> <li>Unbind current driver first</li> </ul>"},{"location":"tui-readme/#container-image-not-found","title":"Container Image Not Found","text":"<ul> <li>Cause: DMA firmware container not built</li> <li>Solutions:</li> <li>The container is now automatically built when needed</li> <li>If automatic build fails, manually build with: <code>podman build -t dma-fw .</code></li> <li>Check Podman installation and internet connectivity</li> </ul>"},{"location":"tui-readme/#insufficient-permissions","title":"Insufficient Permissions","text":"<ul> <li>Cause: Not running with root privileges</li> <li>Solutions:</li> <li>Run with sudo: <code>sudo python3 pcileech.py tui</code></li> <li>Add user to required groups</li> </ul>"},{"location":"tui-readme/#advanced-features","title":"\ud83d\ude80 Advanced Features","text":""},{"location":"tui-readme/#donor-device-configuration","title":"Donor Device Configuration","text":"<p>The TUI provides options for configuring how donor device information is obtained:</p> <ul> <li> <p>Default Mode: By default, the system builds and uses the donor_dump kernel module to extract real device information from the selected PCIe device. This provides the most accurate firmware generation.</p> </li> <li> <p>Local Build Mode: When enabled, this mode skips using the donor_dump kernel module and instead uses either:</p> </li> <li>A previously saved donor information file (specified via the \"Donor Info File\" option)</li> <li>Synthetic donor information generated based on the selected device type</li> </ul> <p>Configuration Options: - Donor Dump: Enable/disable using the donor_dump kernel module (enabled by default) - Local Build: Enable to use a donor info file or synthetic data instead of a real device - Donor Info File: Path to a JSON file containing donor information from a previous run</p> <p>Benefits of Local Build Mode: - No Kernel Module: Useful in environments where building kernel modules is restricted - No Physical Device: Generate firmware without requiring the donor device to be present - Reproducible Builds: Use the same donor information across multiple builds</p> <p>Usage: 1. Select a device in the Device Selection Panel 2. Open the Configuration Panel 3. To use the default mode (recommended), ensure \"Donor Dump\" is enabled 4. To use Local Build mode:    - Enable \"Local Build\" option    - Disable \"Donor Dump\" option    - Optionally specify a \"Donor Info File\" path 5. Start the build process</p> <p>TUI Configuration Panel image would be displayed here</p>"},{"location":"tui-readme/#behavior-profiling","title":"Behavior Profiling","text":"<p>The TUI provides a seamless interface for enabling and configuring behavior profiling:</p> <ul> <li>Enable/Disable: Toggle behavior profiling in the configuration panel</li> <li>Duration Control: Set custom profiling duration (in seconds)</li> <li>Real-time Monitoring: Track profiling progress in the build progress panel</li> <li>Profile Integration: Automatically integrates profiling data into the build process</li> </ul> <p>Configuration Options: - Behavior Profiling: Enable/disable the profiling feature - Profile Duration: Set the duration for capturing device behavior (default: 30.0 seconds) - Device Type: Select specific device type for optimized profiling</p> <p>Benefits: - Enhanced Realism: Generated firmware mimics actual device behavior patterns - Improved Timing: More accurate register access timing based on real measurements - Optimized Performance: Device-specific optimizations based on observed behavior</p> <p>Usage: 1. Select a device in the Device Selection Panel 2. Open the Configuration Panel 3. Enable \"Behavior Profiling\" option 4. Adjust \"Profile Duration\" if needed 5. Start the build process</p> <p>During the build, a dedicated \"Behavior Profiling\" stage will appear in the progress panel, showing real-time status of the profiling process.</p>"},{"location":"tui-readme/#system-status-monitoring","title":"System Status Monitoring","text":"<p>The TUI continuously monitors: - Podman service status - Vivado installation and version - Available USB devices - System resources (CPU, memory, disk) - VFIO support status</p>"},{"location":"tui-readme/#build-process-integration","title":"Build Process Integration","text":"<ul> <li>Container Orchestration: Manages Podman container lifecycle</li> <li>Progress Parsing: Parses build output for progress indicators</li> <li>Resource Tracking: Monitors system resource usage during builds</li> <li>Log Analysis: Analyzes build logs for errors and warnings</li> </ul>"},{"location":"tui-readme/#configuration-validation","title":"Configuration Validation","text":"<ul> <li>Real-time Validation: Validates configuration as you type</li> <li>Compatibility Checks: Warns about incompatible settings</li> <li>Resource Requirements: Estimates resource requirements</li> </ul>"},{"location":"tui-readme/#troubleshooting","title":"\ud83d\udc1b Troubleshooting","text":""},{"location":"tui-readme/#tui-wont-start","title":"TUI Won't Start","text":"<ol> <li> <p>Check Dependencies:    <pre><code>pip install -r requirements-tui.txt\n</code></pre></p> </li> <li> <p>Check Python Version:    <pre><code>python3 --version  # Should be 3.8+\n</code></pre></p> </li> <li> <p>Check Terminal Compatibility:</p> </li> <li>Ensure terminal supports ANSI colors</li> <li>Try different terminal emulator</li> </ol>"},{"location":"tui-readme/#device-detection-issues","title":"Device Detection Issues","text":"<ol> <li>Run as Root:    <pre><code># Using the sudo wrapper (recommended)\n./install-sudo-wrapper.sh  # Install the wrapper first\npcileech-tui-sudo\n\n# Or directly with sudo\nsudo python3 pcileech.py tui\n</code></pre></li> </ol> <p>Note: When running with sudo, you might encounter the error <code>ModuleNotFoundError: No module named 'src'</code>. This happens because sudo changes the Python module search path. Use the provided sudo wrapper script to avoid this issue.</p> <ol> <li> <p>Check lspci:    <pre><code>lspci -Dnn\n</code></pre></p> </li> <li> <p>Verify IOMMU:    <pre><code>dmesg | grep -i iommu\n</code></pre></p> </li> </ol>"},{"location":"tui-readme/#build-failures","title":"Build Failures","text":"<ol> <li> <p>Check Container Image:    <pre><code>podman images | grep dma-fw\n</code></pre></p> </li> <li> <p>Verify Device Binding:    <pre><code>ls -la /dev/vfio/\n</code></pre></p> </li> <li> <p>Check Logs:</p> </li> <li>Use \"View Logs\" button in TUI</li> <li>Check <code>generate.log</code> file</li> </ol>"},{"location":"tui-readme/#development","title":"\ud83d\udee0\ufe0f Development","text":""},{"location":"tui-readme/#architecture","title":"Architecture","text":"<p>The TUI follows a modular architecture:</p> <pre><code>src/tui/\n\u251c\u2500\u2500 main.py              # Main application\n\u251c\u2500\u2500 models/              # Data models\n\u251c\u2500\u2500 core/                # Business logic services\n\u251c\u2500\u2500 widgets/             # Custom UI widgets\n\u251c\u2500\u2500 screens/             # Screen components\n\u2514\u2500\u2500 styles/              # CSS styling\n</code></pre>"},{"location":"tui-readme/#key-components","title":"Key Components","text":"<ul> <li>DeviceManager: PCIe device discovery and management</li> <li>ConfigManager: Configuration and profile management</li> <li>BuildOrchestrator: Build process orchestration</li> <li>StatusMonitor: System status monitoring</li> </ul>"},{"location":"tui-readme/#extending-the-tui","title":"Extending the TUI","text":"<ol> <li>Add New Widgets: Create custom widgets in <code>src/tui/widgets/</code></li> <li>Add New Screens: Create screen components in <code>src/tui/screens/</code></li> <li>Extend Models: Add new data models in <code>src/tui/models/</code></li> <li>Add Services: Create new services in <code>src/tui/core/</code></li> </ol>"},{"location":"tui-readme/#contributing","title":"\ud83e\udd1d Contributing","text":"<ol> <li>Follow the existing code structure</li> <li>Add type hints to all functions</li> <li>Include docstrings for public methods</li> <li>Test with various PCIe devices</li> <li>Ensure backward compatibility</li> </ol>"},{"location":"tui-readme/#license","title":"\ud83d\udcc4 License","text":"<p>Same as the main PCILeech project.</p>"},{"location":"tui-readme/#disclaimer","title":"\u26a0\ufe0f Disclaimer","text":"<p>This tool is intended for educational research and legitimate PCIe development purposes only. Users are responsible for ensuring compliance with all applicable laws and regulations. The authors assume no liability for misuse of this software.</p> <p>Version 0.5.0 - Major release with TUI interface and professional packaging</p>"}]}